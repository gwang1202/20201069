<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>브라우저 환경에서의 고성능 게임 인공지능 시스템 구현에 관한 연구</title>
    
    <!-- MathJax for mathematical formulas -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@400;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        @page {
            size: A4;
            margin: 30mm 25mm 30mm 25mm;
            
            @top-center {
                content: none;
            }
            
            @bottom-center {
                content: counter(page);
                font-size: 11pt;
            }
        }
        
        body {
            font-family: 'Noto Serif KR', 'Batang', '바탕', serif;
            font-size: 11pt;
            line-height: 1.8;
            color: #000;
            background: #f5f5f5;
        }
        
        .thesis-container {
            width: 210mm;
            margin: 0 auto;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        
        .page {
            padding: 30mm 25mm;
            min-height: 297mm;
            page-break-after: always;
            position: relative;
        }
        
        .page-number {
            position: absolute;
            bottom: 20mm;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11pt;
        }
        
        /* 표지 */
        .cover-page {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        
        .degree-type {
            font-size: 16pt;
            font-weight: 600;
            margin-bottom: 80px;
        }
        
        .thesis-title-main {
            font-size: 22pt;
            font-weight: 700;
            line-height: 1.5;
            margin-bottom: 30px;
        }
        
        .thesis-title-sub {
            font-size: 18pt;
            font-weight: 600;
            margin-bottom: 120px;
        }
        
        .submission-date {
            font-size: 14pt;
            margin-bottom: 60px;
        }
        
        .university-name {
            font-size: 20pt;
            font-weight: 700;
            margin-bottom: 20px;
        }
        
        .department-name {
            font-size: 16pt;
            margin-bottom: 40px;
        }
        
        .author-name {
            font-size: 16pt;
            font-weight: 600;
        }
        
        /* 인준서 */
        .approval-page {
            display: flex;
            flex-direction: column;
            justify-content: center;
            text-align: center;
        }
        
        .approval-title {
            font-size: 18pt;
            font-weight: 700;
            margin-bottom: 60px;
        }
        
        .approval-text {
            font-size: 14pt;
            line-height: 2;
            margin-bottom: 80px;
        }
        
        .committee {
            margin-top: 80px;
        }
        
        .committee-member {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 30px 0;
            font-size: 13pt;
        }
        
        .committee-role {
            width: 120px;
            text-align: right;
            margin-right: 40px;
        }
        
        .committee-name {
            width: 150px;
            text-align: left;
        }
        
        .committee-sign {
            width: 100px;
            border-bottom: 1px solid #000;
            margin-left: 40px;
        }
        
        /* 초록 */
        .abstract-kr, .abstract-en {
            text-align: justify;
        }
        
        .abstract-title {
            font-size: 18pt;
            font-weight: 700;
            text-align: center;
            margin-bottom: 40px;
        }
        
        .abstract-content p {
            text-indent: 2em;
            margin-bottom: 15px;
        }
        
        .keywords {
            margin-top: 40px;
            font-weight: 600;
        }
        
        /* 목차 */
        .toc-title {
            font-size: 18pt;
            font-weight: 700;
            text-align: center;
            margin-bottom: 50px;
        }
        
        .toc-item {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            font-size: 12pt;
        }
        
        .toc-text {
            flex: 1;
        }
        
        .toc-dots {
            flex: 0 1 auto;
            border-bottom: 1px dotted #333;
            margin: 0 10px;
            min-width: 50px;
        }
        
        .toc-page-num {
            width: 40px;
            text-align: right;
        }
        
        .toc-chapter {
            font-weight: 600;
            margin-top: 20px;
        }
        
        .toc-section {
            padding-left: 20px;
        }
        
        .toc-subsection {
            padding-left: 40px;
            font-size: 11pt;
        }
        
        /* 본문 스타일 */
        .chapter {
            page-break-before: always;
        }
        
        .chapter-title {
            font-size: 20pt;
            font-weight: 700;
            text-align: center;
            margin-bottom: 50px;
            padding-bottom: 20px;
            border-bottom: 3px solid #000;
        }
        
        .section-title {
            font-size: 16pt;
            font-weight: 700;
            margin-top: 40px;
            margin-bottom: 20px;
            padding-left: 10px;
            border-left: 5px solid #333;
        }
        
        .subsection-title {
            font-size: 14pt;
            font-weight: 600;
            margin-top: 30px;
            margin-bottom: 15px;
            padding-left: 20px;
        }
        
        .subsubsection-title {
            font-size: 12pt;
            font-weight: 600;
            margin-top: 20px;
            margin-bottom: 10px;
            padding-left: 30px;
        }
        
        /* 문단 스타일 */
        .body-text {
            text-align: justify;
            text-indent: 2em;
            margin-bottom: 12px;
        }
        
        .body-text.no-indent {
            text-indent: 0;
        }
        
        /* 그림과 표 */
        .figure, .table-container {
            margin: 30px 0;
            text-align: center;
        }
        
        .figure-image {
            max-width: 100%;
            border: 1px solid #ddd;
            padding: 10px;
            background: #fafafa;
        }
        
        .figure-caption, .table-caption {
            margin-top: 15px;
            font-size: 10pt;
            font-weight: 600;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 0 auto;
            font-size: 10pt;
        }
        
        th {
            background: #333;
            color: white;
            padding: 10px;
            font-weight: 600;
            border: 1px solid #333;
        }
        
        td {
            padding: 8px;
            border: 1px solid #ddd;
            text-align: center;
        }
        
        tbody tr:nth-child(even) {
            background: #f9f9f9;
        }
        
        /* 수식 */
        .equation {
            margin: 20px 0;
            padding: 15px;
            background: #f9f9f9;
            border-left: 3px solid #333;
            text-align: center;
        }
        
        /* 코드 블록 */
        .code-block {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 9pt;
            border-radius: 4px;
            overflow-x: auto;
            line-height: 1.5;
            white-space: pre-wrap;
        }
        
        .code-block pre {
            margin: 0;
            color: #212529;
        }
        
        .code-block .comment {
            color: #6a737d;
            font-style: italic;
        }
        
        .code-block .keyword {
            color: #d73a49;
            font-weight: bold;
        }
        
        .code-block .string {
            color: #032f62;
        }
        
        .code-block .number {
            color: #005cc5;
        }
        
        /* 차트 컨테이너 */
        .chart-container {
            max-width: 100%;
            overflow-x: auto;
            margin: 20px 0;
        }
        
        /* 인용문 */
        .quote {
            margin: 20px 20px;
            padding: 15px;
            border-left: 4px solid #666;
            background: #f9f9f9;
            font-style: italic;
        }
        
        /* 정의, 정리 */
        .definition, .theorem {
            margin: 25px 0;
            padding: 20px;
            border: 2px solid #333;
            background: #fafafa;
        }
        
        .definition-title, .theorem-title {
            font-weight: 700;
            margin-bottom: 10px;
        }
        
        /* 리스트 */
        .body-list {
            margin: 15px 0;
            padding-left: 40px;
        }
        
        .body-list li {
            margin: 8px 0;
        }
        
        /* 참고문헌 */
        .references {
            font-size: 10pt;
            line-height: 1.6;
        }
        
        .ref-item {
            margin: 15px 0;
            padding-left: 30px;
            text-indent: -30px;
        }
        
        .ref-number {
            font-weight: 600;
        }
        
        /* 각주 */
        .footnote {
            font-size: 9pt;
            border-top: 1px solid #ddd;
            margin-top: 40px;
            padding-top: 10px;
        }
        
        /* 페이지 레이아웃 */
        @media print {
            body {
                background: white;
            }
            
            .thesis-container {
                box-shadow: none;
            }
            
            .page {
                page-break-after: always;
                page-break-inside: avoid;
            }
            
            .chapter {
                page-break-before: always;
            }
            
            .figure, .table-container {
                page-break-inside: avoid;
            }
        }
        
        /* 하이라이트 */
        .highlight {
            background: linear-gradient(transparent 70%, #ffeb3b 70%);
            padding: 2px;
        }
        
        /* 번호 매기기 */
        .chapter-number {
            font-size: 16pt;
            margin-bottom: 10px;
            text-align: center;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="thesis-container">
        
        <!-- 표지 -->
        <div class="page cover-page">
            <div class="degree-type">졸업논문</div>
            <div class="thesis-title-main">
                브라우저 환경에서의<br>
                고성능 게임 인공지능 시스템<br>
                구현에 관한 연구
            </div>
            <div class="thesis-title-sub">
                - 완전 정보 보드게임을 중심으로 -
            </div>
            <div class="submission-date">2025년 11월</div>
            <div class="university-name">호남대학교</div>
            <div class="department-name">컴퓨터공학과</div>
            <div class="author-name">김 동 휘</div>
        </div>
        
        <!-- 인준서 -->
        <div class="page approval-page">
            <div class="approval-title">
                브라우저 환경에서의<br>
                고성능 게임 인공지능 시스템<br>
                구현에 관한 연구
            </div>
            <div class="approval-text">
                이 논문을 졸업논문으로 제출함<br><br>
                2025년 11월<br><br>
                호남대학교<br>
                컴퓨터공학과<br>
                김동휘
            </div>

        </div>
        
        <!-- 국문초록 -->
        <div class="page abstract-kr">
            <div class="abstract-title">국문초록</div>
            <div class="abstract-content">
                <p>
                    본 논문은 웹 브라우저 환경에서 JavaScript와 Web Workers를 활용하여 구현한 고성능 게임 인공지능 시스템의 설계, 구현 및 최적화 방법론을 제시한다. 특히 오셀로(Othello)라는 완전 정보 보드게임을 대상으로, 전통적으로 네이티브 애플리케이션의 영역으로 여겨졌던 복잡한 AI 알고리즘을 브라우저에서 효율적으로 실행할 수 있음을 실증적으로 입증한다.
                </p>
                <p>
                    연구의 핵심 기여는 다음과 같다. 첫째, Alpha-Beta 가지치기를 포함한 Minimax와 NegaScout(Principal Variation Search) 알고리즘을 JavaScript 환경에 최적화하여 구현하였다. 이를 통해 탐색 공간을 O(b^d)에서 O(b^(d/2))로 축소하여 실시간 응답이 가능한 수준의 성능을 달성하였다.
                </p>
                <p>
                    둘째, 게임의 특성을 반영한 정교한 평가 함수를 설계하였다. 오셀로의 경우 게임 단계를 4단계(Opening, Midgame, Lategame, Endgame)로 구분하고, 각 단계별로 6가지 평가 요소(위치 가중치, 이동성, 안정성, 코너 지배, 프론티어 디스크, 패리티)의 가중치를 차등 적용하는 다차원 평가 시스템을 개발하였다.
                </p>
                <p>
                    셋째, 브라우저의 메모리 제약을 극복하기 위한 효율적인 캐싱 전략을 제시하였다. Zobrist 해싱 기반의 Transposition Table을 구현하여 중복 계산을 방지하고, LRU(Least Recently Used) 교체 정책을 통해 메모리 사용량을 제한하면서도 65-78%의 캐시 적중률을 달성하였다.
                </p>
                <p>
                    실험 결과, 오셀로 엔진은 14개 이하의 빈 칸에서 완벽한 플레이(perfect play)를 제공하며, NegaScout 알고리즘으로 초당 120,000개의 노드를 탐색하였다. 순수 JavaScript 환경에서 초당 120,000 노드 탐색이라는 실용적인 성능을 달성하였으며, 이는 WebAssembly 없이도 고성능 AI 시스템 구축이 가능함을 입증한다.
                </p>
                <p>
                    본 연구는 웹 기술의 발전과 함께 브라우저가 단순한 문서 뷰어를 넘어 복잡한 AI 시스템을 실행할 수 있는 강력한 컴퓨팅 플랫폼으로 진화했음을 입증한다. 또한 서버 인프라 없이도 고품질 AI 서비스를 제공할 수 있는 새로운 패러다임을 제시하며, 특히 교육 및 연구 분야에서의 활용 가능성을 확대한다.
                </p>
                <div class="keywords">
                    <strong>주제어:</strong> 게임 인공지능, 브라우저 컴퓨팅, Minimax 알고리즘, Alpha-Beta 가지치기, NegaScout, Transposition Tables, Web Workers, JavaScript 성능 최적화, 오셀로
                </div>
            </div>
            <div class="page-number">i</div>
        </div>
        
        <!-- 목차 -->
        <div class="page">
            <div class="toc-title">목 차</div>
            
            <div class="toc-item">
                <span class="toc-text">국문초록</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">i</span>
            </div>
            
            <div class="toc-item">
                <span class="toc-text">목차</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">iii</span>
            </div>
            
            <div class="toc-item">
                <span class="toc-text">표 목차</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">v</span>
            </div>
            
            <div class="toc-item">
                <span class="toc-text">그림 목차</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">vi</span>
            </div>
            
            <div class="toc-item toc-chapter">
                <span class="toc-text">제1장 서론</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">1</span>
            </div>
            
            <div class="toc-item toc-section">
                <span class="toc-text">1.1 연구 배경 및 필요성</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">1</span>
            </div>
            
            <div class="toc-item toc-section">
                <span class="toc-text">1.2 연구 목적</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">4</span>
            </div>
            
            <div class="toc-item toc-section">
                <span class="toc-text">1.3 연구 범위 및 방법</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">6</span>
            </div>
            
            <div class="toc-item toc-section">
                <span class="toc-text">1.4 논문의 구성</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">8</span>
            </div>
            
            <div class="toc-item toc-chapter">
                <span class="toc-text">제2장 이론적 배경</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">10</span>
            </div>
            
            <div class="toc-item toc-section">
                <span class="toc-text">2.1 게임 트리 탐색 알고리즘</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">10</span>
            </div>
            
            <div class="toc-item toc-subsection">
                <span class="toc-text">2.1.1 Minimax 알고리즘</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">10</span>
            </div>
            
            <div class="toc-item toc-subsection">
                <span class="toc-text">2.1.2 Alpha-Beta 가지치기</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">14</span>
            </div>
            
            <div class="toc-item toc-subsection">
                <span class="toc-text">2.1.3 NegaScout 알고리즘</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">18</span>
            </div>
            
            <div class="toc-item toc-section">
                <span class="toc-text">2.2 웹 브라우저 컴퓨팅 환경</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">22</span>
            </div>
            
            <div class="toc-item toc-subsection">
                <span class="toc-text">2.2.1 JavaScript 엔진 최적화</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">22</span>
            </div>
            
            <div class="toc-item toc-subsection">
                <span class="toc-text">2.2.2 Web Workers API</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">26</span>
            </div>
            
            <div class="toc-item toc-section">
                <span class="toc-text">2.3 관련 연구</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">30</span>
            </div>
            
            <div class="toc-item toc-chapter">
                <span class="toc-text">제3장 시스템 설계 및 구현</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">35</span>
            </div>
            
            <div class="toc-item toc-section">
                <span class="toc-text">3.1 시스템 아키텍처</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">35</span>
            </div>
            
            <div class="toc-item toc-section">
                <span class="toc-text">3.2 탐색 알고리즘 구현</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">42</span>
            </div>
            
            <div class="toc-item toc-section">
                <span class="toc-text">3.3 평가 함수 설계</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">50</span>
            </div>
            
            <div class="toc-item toc-chapter">
                <span class="toc-text">제4장 최적화 기법</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">60</span>
            </div>
            
            <div class="toc-item toc-section">
                <span class="toc-text">4.1 Transposition Table</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">60</span>
            </div>
            
            <div class="toc-item toc-section">
                <span class="toc-text">4.2 Move Ordering</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">65</span>
            </div>
            
            <div class="toc-item toc-section">
                <span class="toc-text">4.3 메모리 최적화</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">70</span>
            </div>
            
            <div class="toc-item toc-chapter">
                <span class="toc-text">제5장 실험 및 평가</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">75</span>
            </div>
            
            <div class="toc-item toc-section">
                <span class="toc-text">5.1 실험 환경</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">75</span>
            </div>
            
            <div class="toc-item toc-section">
                <span class="toc-text">5.2 성능 평가</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">78</span>
            </div>
            
            <div class="toc-item toc-section">
                <span class="toc-text">5.3 결과 분석</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">85</span>
            </div>
            
            <div class="toc-item toc-chapter">
                <span class="toc-text">제6장 결론</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">90</span>
            </div>
            
            <div class="toc-item toc-section">
                <span class="toc-text">6.1 연구 성과</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">90</span>
            </div>
            
            <div class="toc-item toc-section">
                <span class="toc-text">6.2 향후 연구 과제</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">93</span>
            </div>
            
            <div class="toc-item toc-chapter">
                <span class="toc-text">참고문헌</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">95</span>
            </div>
            
            <div class="toc-item toc-chapter">
                <span class="toc-text">Abstract</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">99</span>
            </div>
            
            <div class="page-number">iii</div>
        </div>
        
        <!-- 표 목차 -->
        <div class="page">
            <div class="toc-title">표 목차</div>
            
            <div class="toc-item">
                <span class="toc-text">표 2.1 게임 복잡도 비교</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">12</span>
            </div>
            
            <div class="toc-item">
                <span class="toc-text">표 2.2 JavaScript 엔진별 성능 특성</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">24</span>
            </div>
            
            <div class="toc-item">
                <span class="toc-text">표 3.1 오셀로 게임 상태 구조</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">52</span>
            </div>
            
            <div class="toc-item">
                <span class="toc-text">표 3.2 오셀로 게임 단계별 가중치</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">55</span>
            </div>
            
            <div class="toc-item">
                <span class="toc-text">표 4.1 Move Ordering 우선순위</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">66</span>
            </div>
            
            <div class="toc-item">
                <span class="toc-text">표 5.1 실험 환경 사양</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">76</span>
            </div>
            
            <div class="toc-item">
                <span class="toc-text">표 5.2 난이도별 탐색 성능</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">79</span>
            </div>
            
            <div class="toc-item">
                <span class="toc-text">표 5.3 최적화 기법별 효과</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">81</span>
            </div>
            
            <div class="toc-item">
                <span class="toc-text">표 5.4 브라우저별 벤치마크 결과</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">83</span>
            </div>
            
            
            
            <div class="page-number">v</div>
        </div>
        
        <!-- 그림 목차 -->
        <div class="page">
            <div class="toc-title">그림 목차</div>
            
            <div class="toc-item">
                <span class="toc-text">그림 3.1 시스템 아키텍처</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">36</span>
            </div>
            
            <div class="toc-item">
                <span class="toc-text">그림 4.1 캐시 적중률 분포</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">61</span>
            </div>
            
            <div class="toc-item">
                <span class="toc-text">그림 5.1 브라우저별 성능 비교</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">82</span>
            </div>
            
            <div class="toc-item">
                <span class="toc-text">그림 5.2 최적화 누적 효과</span>
                <span class="toc-dots"></span>
                <span class="toc-page-num">84</span>
            </div>
            
            <div class="page-number">vi</div>
        </div>
        
        <!-- 제1장 서론 -->
        <div class="page chapter">
            <div class="chapter-number">제 1 장</div>
            <div class="chapter-title">서 론</div>
            
            <div class="section-title">1.1 연구 배경 및 필요성</div>
            
            <p class="body-text">
                게임 인공지능(Game Artificial Intelligence)은 1950년 Claude Shannon이 체스 프로그래밍에 관한 논문을 발표한 이래로 인공지능 연구의 핵심 분야로 자리잡아왔다. Arthur Samuel의 체커스 프로그램(1959), IBM Deep Blue의 체스 세계 챔피언 Garry Kasparov 승리(1997), 그리고 DeepMind AlphaGo의 바둑 정상 정복(2016)에 이르기까지, 게임 AI는 지속적으로 인공지능 기술의 한계를 확장하며 발전해왔다.
            </p>
            
            <p class="body-text">
                전통적으로 고성능 게임 AI 시스템은 C/C++ 등의 저수준 프로그래밍 언어로 작성되어 네이티브 환경에서 실행되어왔다. 이는 게임 트리 탐색에 요구되는 막대한 계산량을 처리하기 위해 하드웨어 자원을 최대한 효율적으로 활용해야 했기 때문이다. Minimax 알고리즘의 시간 복잡도가 O(b^d) (b: 분기 계수, d: 탐색 깊이)에 달하는 상황에서, 실시간 응답을 보장하기 위해서는 극도로 최적화된 구현이 필수적이었다.
            </p>
            
            <p class="body-text">
                그러나 최근 웹 기술의 급격한 발전은 이러한 패러다임에 변화를 가져오고 있다. 현대의 JavaScript 엔진들 - Google의 V8, Mozilla의 SpiderMonkey, Apple의 JavaScriptCore - 은 JIT(Just-In-Time) 컴파일 기술을 통해 네이티브 코드에 근접한 성능을 제공한다. 특히 V8 엔진의 경우, Hidden Classes, Inline Caching, Crankshaft/TurboFan 최적화 컴파일러 등의 기술을 통해 정적 타입 언어에 필적하는 실행 속도를 달성하고 있다.
            </p>
            
            <p class="body-text">
                Web Workers API의 도입은 브라우저에서의 병렬 컴퓨팅을 가능하게 했다. 메인 스레드와 독립적으로 실행되는 Worker 스레드는 UI 블로킹 없이 무거운 계산 작업을 수행할 수 있으며, postMessage 인터페이스를 통한 효율적인 메시지 패싱을 지원한다. 이는 게임 AI와 같이 계산 집약적인 작업을 브라우저에서 실행하는 데 있어 중요한 기술적 토대가 되었다.
            </p>
            
            <p class="body-text">
                브라우저 기반 AI 시스템은 다음과 같은 실무적 장점을 제공한다:
            </p>
            
            <ul class="body-list">
                <li><strong>즉각적 접근성:</strong> 사용자는 별도의 설치 과정 없이 URL 접속만으로 즉시 시스템을 사용할 수 있다. 이는 사용자 진입 장벽을 현저히 낮추며, 특히 교육 환경에서 큰 이점이 된다.</li>
                <li><strong>플랫폼 독립성:</strong> 단일 코드베이스로 Windows, macOS, Linux, iOS, Android 등 모든 주요 플랫폼을 지원할 수 있다. 이는 개발 및 유지보수 비용을 크게 절감시킨다.</li>
                <li><strong>서버 비용 절감:</strong> 모든 계산이 클라이언트에서 수행되므로 서버 인프라가 불필요하다. 대규모 사용자를 대상으로 서비스할 경우, 이는 막대한 비용 절감 효과를 가져온다.</li>
                <li><strong>프라이버시 보장:</strong> 게임 데이터가 서버로 전송되지 않으므로 완벽한 프라이버시가 보장된다. GDPR, CCPA 등 강화되는 개인정보 보호 규정에 자동으로 부합한다.</li>
            </ul>
            
            <p class="body-text">
                이러한 배경에서 본 연구는 브라우저 환경에서 네이티브 애플리케이션과 경쟁 가능한 수준의 고성능 게임 AI 시스템을 구현하는 것을 목표로 한다. 특히 오셀로라는 완전 정보 보드게임을 대상으로, JavaScript와 Web Workers를 활용한 효율적인 AI 엔진을 설계하고 구현한다.
            </p>
            
            <div class="section-title">1.2 연구 목적</div>
            
            <p class="body-text">
                본 연구의 주요 목적은 브라우저 환경에서 실시간으로 동작 가능한 고성능 게임 AI 시스템을 구현하고, 이를 통해 웹 기술의 가능성을 확장하는 것이다. 구체적인 연구 목표는 다음과 같다:
            </p>
            
            <p class="body-text no-indent">
                첫째, JavaScript 환경에 최적화된 게임 트리 탐색 알고리즘을 설계하고 구현한다. 가비지 컬렉션의 영향을 최소화하면서도 효율적인 메모리 관리가 가능한 구조를 개발하고, JIT 컴파일러의 최적화를 최대한 활용할 수 있는 코드 패턴을 적용한다.
            </p>
            
            <p class="body-text no-indent">
                둘째, 게임별 특성을 반영한 정교한 평가 함수를 설계한다. 단순한 휴리스틱을 넘어 게임 단계별 동적 가중치 조정과 패턴 인식을 통합한 다차원 평가 시스템을 구축한다.
            </p>
            
            <p class="body-text no-indent">
                셋째, 브라우저의 제한된 리소스 환경에서 최대 성능을 발휘할 수 있는 최적화 기법을 개발한다. Transposition Table, Move Ordering, Iterative Deepening 등의 고급 기법을 JavaScript 환경에 맞게 재설계한다.
            </p>
            
            <p class="body-text no-indent">
                넷째, 실험적 검증을 통해 구현된 시스템의 성능을 정량적으로 평가하고, 네이티브 구현과의 성능 격차를 분석한다.
            </p>
            
            <div class="section-title">1.3 연구 범위 및 방법</div>
            
            <p class="body-text">
                본 연구의 대상 게임으로는 오셀로(Othello/Reversi)를 선정하였다. 이 게임은 완전 정보 게임(perfect information game)으로서 모든 게임 상태가 양 플레이어에게 공개되어 있으며, 확률적 요소가 없어 순수한 전략적 사고만으로 승부가 결정된다는 특징을 갖는다.
            </p>
            
            <div class="table-container">
                <div class="table-caption">표 1.1 오셀로 게임 특성</div>
                <table>
                    <thead>
                        <tr>
                            <th>특성</th>
                            <th>오셀로 (Othello)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>보드 크기</td>
                            <td>8×8</td>
                        </tr>
                        <tr>
                            <td>평균 분기 계수</td>
                            <td>~10</td>
                        </tr>
                        <tr>
                            <td>게임 복잡도</td>
                            <td>10<sup>58</sup></td>
                        </tr>
                        <tr>
                            <td>평균 게임 길이</td>
                            <td>58-60수</td>
                        </tr>
                        <tr>
                            <td>주요 전략 요소</td>
                            <td>위치 제어, 안정성</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <p class="body-text">
                연구 방법론은 다음과 같은 단계로 구성된다:
            </p>
            
            <ul class="body-list">
                <li><strong>이론적 분석:</strong> 기존 게임 AI 알고리즘의 이론적 기반을 분석하고, JavaScript 환경의 특성을 고려한 최적화 방안을 도출한다.</li>
                <li><strong>시스템 설계:</strong> 모듈화되고 확장 가능한 시스템 아키텍처를 설계하고, Web Workers를 활용한 비동기 처리 구조를 구현한다.</li>
                <li><strong>알고리즘 구현:</strong> Minimax, Alpha-Beta, NegaScout 등의 탐색 알고리즘과 게임별 평가 함수를 구현한다.</li>
                <li><strong>최적화 적용:</strong> 캐싱, 이동 순서 정렬, 메모리 관리 등 다양한 최적화 기법을 적용한다.</li>
                <li><strong>성능 평가:</strong> 체계적인 실험을 통해 시스템의 성능을 측정하고 분석한다.</li>
            </ul>
            
            <div class="section-title">1.4 논문의 구성</div>
            
            <p class="body-text">
                본 논문은 다음과 같이 구성된다. 제2장에서는 게임 트리 탐색 알고리즘의 이론적 배경과 웹 브라우저 컴퓨팅 환경의 기술적 특성을 살펴보고, 관련 선행 연구들을 검토한다. 제3장에서는 제안하는 시스템의 전체 아키텍처와 핵심 구성 요소들의 설계 및 구현 방법을 상세히 기술한다. 제4장에서는 JavaScript 환경에 특화된 다양한 최적화 기법들을 제시한다. 제5장에서는 구현된 시스템의 성능을 실험적으로 평가하고 결과를 분석한다. 마지막으로 제6장에서는 연구의 결론을 도출하고 향후 연구 방향을 제시한다.
            </p>
            
            <div class="page-number">1</div>
        </div>
        
        <!-- 제2장 이론적 배경 -->
        <div class="page chapter">
            <div class="chapter-number">제 2 장</div>
            <div class="chapter-title">이론적 배경</div>
            
            <div class="section-title">2.1 게임 트리 탐색 알고리즘</div>
            
            <div class="subsection-title">2.1.1 Minimax 알고리즘</div>
            
            <p class="body-text">
                Minimax 알고리즘은 John von Neumann이 1928년에 제시한 게임 이론의 핵심 개념으로, 2인 제로섬 게임에서 최적 전략을 찾는 기본적인 방법이다. 알고리즘의 기본 원리는 자신의 이익을 최대화(maximize)하고 상대의 이익을 최소화(minimize)하는 수를 선택하는 것이다.
            </p>
            
            <div class="definition">
                <div class="definition-title">정의 2.1 (Minimax 값)</div>
                <p class="body-text no-indent">
                    게임 트리의 노드 n에서 Minimax 값 V(n)은 다음과 같이 재귀적으로 정의된다:
                </p>
                <div class="equation">
                    \[V(n) = \begin{cases}
                        u(n) & \text{if } n \text{ is terminal} \\
                        \max_{c \in children(n)} V(c) & \text{if } n \text{ is MAX node} \\
                        \min_{c \in children(n)} V(c) & \text{if } n \text{ is MIN node}
                    \end{cases}\]
                </div>
                <p class="body-text no-indent">
                    여기서 u(n)은 단말 노드 n에서의 효용 함수(utility function) 값이다.
                </p>
            </div>
            
            <p class="body-text">
                순수한 Minimax 알고리즘의 시간 복잡도는 O(b^d)이며, 여기서 b는 평균 분기 계수(branching factor), d는 탐색 깊이이다. 공간 복잡도는 깊이 우선 탐색을 사용할 경우 O(bd)이다. 이러한 지수적 복잡도로 인해 실제 게임에서는 다양한 최적화 기법이 필수적이다.
            </p>
            
            <div class="code-block">
<pre style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 12px; overflow-x: auto; font-family: 'Consolas', 'Monaco', monospace; font-size: 8.5pt; line-height: 1.5; color: #212529; white-space: pre-wrap; word-wrap: break-word;">// Minimax 알고리즘 기본 구현 (개념 설명용 단순화 버전)
const minimax = (board, depth, isMaximizing, color) => {
    // 단말 노드: 깊이 0이거나 게임 종료
    if (depth === 0 || isGameOver(board)) {
        return evaluate(board, color);
    }
    
    const opponent = color === BLACK ? WHITE : BLACK;
    const moves = getMoves(board, isMaximizing ? color : opponent);
    
    if (isMaximizing) {
        // MAX 노드: 최대값 선택
        let maxScore = -Infinity;
        for (const {x, y} of moves) {
            const newBoard = clone(board);
            doMove(newBoard, x, y, color);
            const score = minimax(newBoard, depth - 1, false, color);
            maxScore = Math.max(maxScore, score);
        }
        return maxScore;
    } else {
        // MIN 노드: 최소값 선택
        let minScore = Infinity;
        for (const {x, y} of moves) {
            const newBoard = clone(board);
            doMove(newBoard, x, y, opponent);
            const score = minimax(newBoard, depth - 1, true, color);
            minScore = Math.min(minScore, score);
        }
        return minScore;
    }
};</pre>
            </div>
            
            <div class="subsection-title">2.1.2 Alpha-Beta 가지치기</div>
            
            <p class="body-text">
                Alpha-Beta 가지치기는 McCarthy가 1956년 Dartmouth 워크샵에서 처음 제안했으며, 이후 Knuth와 Moore에 의해 체계적으로 분석되었다. 이 기법은 탐색 과정에서 불필요한 노드를 제거하여 동일한 결과를 보장하면서도 탐색 공간을 크게 줄인다.
            </p>
            
            <div class="theorem">
                <div class="theorem-title">정리 2.1 (Alpha-Beta 가지치기의 정확성)</div>
                <p class="body-text no-indent">
                    Alpha-Beta 가지치기를 적용한 Minimax 탐색은 순수한 Minimax 탐색과 동일한 결과를 반환한다.
                </p>
                <p class="body-text no-indent">
                    <strong>증명:</strong> Alpha-Beta 가지치기는 현재까지 발견된 최선의 수보다 나쁜 수로 이어지는 부분 트리만을 제거한다. MAX 노드에서 이미 발견된 값 α보다 작거나 같은 값을 가진 자식 노드는 최종 선택에 영향을 주지 않으므로 안전하게 제거할 수 있다. MIN 노드에서도 마찬가지로 β보다 크거나 같은 값을 가진 자식 노드를 제거할 수 있다. 따라서 가지치기된 노드들은 최종 결과에 영향을 주지 않는다. □
                </p>
            </div>
            
            <p class="body-text">
                최적의 이동 순서(move ordering)가 주어진 경우, Alpha-Beta 가지치기의 시간 복잡도는 O(b^(d/2))로 개선된다. 이는 동일한 시간에 두 배 깊이까지 탐색할 수 있음을 의미한다. 평균적인 경우 O(b^(3d/4))의 복잡도를 보인다.
            </p>
            
            <div class="subsection-title">2.1.3 NegaScout 알고리즘</div>
            
            <p class="body-text">
                NegaScout(또는 Principal Variation Search, PVS)는 Reinefeld가 1983년에 제안한 알고리즘으로, Alpha-Beta 가지치기를 더욱 개선한 방법이다. 핵심 아이디어는 null-window search를 활용하여 대부분의 노드를 빠르게 검증하는 것이다.
            </p>
            
            <p class="body-text">
                NegaScout는 첫 번째 자식 노드를 전체 window [α, β]로 탐색한 후, 나머지 노드들을 null-window [α, α+1]로 탐색한다. 만약 null-window 탐색이 실패하면(즉, 결과가 α보다 크면) 전체 window로 재탐색한다. 이 방법은 대부분의 노드가 실제로 최선의 수가 아니라는 가정 하에 효율적이다.
            </p>
            
            <div class="code-block">
<pre style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 12px; overflow-x: auto; font-family: 'Consolas', 'Monaco', monospace; font-size: 8.5pt; line-height: 1.5; color: #212529; white-space: pre-wrap; word-wrap: break-word;">// NegaScout 알고리즘 실제 구현 (aiWorker.js)
const negaScout = (board, depth, color, alpha, beta, startTime, timeLimit) => {
    nodes++;  // 탐색 노드 수 증가
    
    // 시간 초과 체크
    if (Date.now() - startTime > timeLimit) return 0;
    
    // Transposition Table 조회
    const hash = board.flat().join('') + color + depth;
    const cached = ttable.get(hash);
    if (cached && cached.depth >= depth) return cached.score;
    
    // 단말 노드: 평가 함수 호출
    if (depth === 0) return evaluate(board, color);
    
    const opponent = color === BLACK ? WHITE : BLACK;
    const moves = getMoves(board, color);
    
    // 이동 불가: 상대에게 턴 넘김
    if (moves.length === 0) {
        const oppMoves = getMoves(board, opponent);
        if (oppMoves.length === 0) return evaluate(board, color);
        return -negaScout(board, depth, opponent, -beta, -alpha, startTime, timeLimit);
    }
    
    // Move Ordering 적용
    const orderedMoves = orderMoves(board, color, moves, depth);
    let bestScore = -Infinity;
    let first = true;
    
    for (const {x, y} of orderedMoves) {
        if (Date.now() - startTime > timeLimit) break;
        
        const newBoard = clone(board);
        doMove(newBoard, x, y, color);
        
        let score;
        if (first) {
            // 첫 번째 수: 전체 window로 탐색
            score = -negaScout(newBoard, depth-1, opponent, -beta, -alpha, 
                              startTime, timeLimit);
            first = false;
        } else {
            // 나머지 수: Null-window search
            score = -negaScout(newBoard, depth-1, opponent, -alpha-1, -alpha, 
                              startTime, timeLimit);
            
            // 재탐색 필요 여부 확인
            if (alpha < score && score < beta) {
                score = -negaScout(newBoard, depth-1, opponent, -beta, -score, 
                                  startTime, timeLimit);
            }
        }
        
        if (score > bestScore) {
            bestScore = score;
            if (score >= beta) {
                updateHistory(x, y, depth);  // Beta cutoff
            }
        }
        
        alpha = Math.max(alpha, score);
        if (alpha >= beta) break;  // Alpha-Beta pruning
    }
    
    // Transposition Table에 저장
    if (ttable.size > 400000) {
        // 캐시 크기 제한
        const keys = [...ttable.keys()];
        for (let i = 0; i < keys.length / 2; i++) {
            ttable.delete(keys[i]);
        }
    }
    ttable.set(hash, {score: bestScore, depth: depth});
    
    return bestScore;
};

// Iterative Deepening 구현
const iterDeep = (board, color, maxDepth, timeLimit) => {
    const startTime = Date.now();
    nodes = 0;
    
    const moves = getMoves(board, color);
    if (!moves.length) return null;
    
    // 코너가 있으면 즉시 선택
    for (const [x, y] of moves) {
        if ((x===0||x===7) && (y===0||y===7)) return [x, y];
    }
    
    const opponent = color === BLACK ? WHITE : BLACK;
    let bestMove = null;
    let bestScore = -Infinity;
    
    // 깊이 1부터 maxDepth까지 점진적 탐색
    for (let depth = 1; depth <= maxDepth; depth++) {
        if (Date.now() - startTime > timeLimit * 0.85) break;
        
        const orderedMoves = orderMoves(board, color, moves, depth);
        let depthBest = -Infinity;
        let depthMove = null;
        
        for (const {x, y} of orderedMoves) {
            if (Date.now() - startTime > timeLimit * 0.9) break;
            
            const newBoard = clone(board);
            doMove(newBoard, x, y, color);
            
            let score;
            if (depth >= 4 && bestScore !== -Infinity) {
                // Aspiration Search (depth 4 이상)
                score = -aspirationSearch(newBoard, opponent, depth-1, 
                                         -bestScore, startTime, timeLimit);
            } else {
                score = -negaScout(newBoard, depth-1, opponent, 
                                  -Infinity, Infinity, startTime, timeLimit);
            }
            
            if (score > depthBest) {
                depthBest = score;
                depthMove = [x, y];
            }
        }
        
        if (depthBest > bestScore) {
            bestScore = depthBest;
            bestMove = depthMove;
        }
    }
    
    return bestMove || moves[0];
};</pre>
            </div>
            
            <div class="section-title">2.2 웹 브라우저 컴퓨팅 환경</div>
            
            <div class="subsection-title">2.2.1 JavaScript 엔진 최적화</div>
            
            <p class="body-text">
                현대 JavaScript 엔진은 다양한 최적화 기법을 통해 동적 언어의 한계를 극복하고 있다. Google V8 엔진을 중심으로 주요 최적화 기법을 살펴보면 다음과 같다:
            </p>
            
            <p class="body-text">
                <strong>Hidden Classes:</strong> JavaScript는 동적 타입 언어이지만, V8은 내부적으로 Hidden Classes를 생성하여 객체의 프로퍼티 접근을 최적화한다. 동일한 순서로 동일한 프로퍼티를 가진 객체들은 같은 Hidden Class를 공유하며, 이를 통해 프로퍼티 접근이 O(1) 시간에 가능해진다.
            </p>
            
            <p class="body-text">
                <strong>Inline Caching:</strong> 함수 호출 시 매개변수의 타입 정보를 캐싱하여, 동일한 타입의 매개변수로 반복 호출될 때 타입 체크를 생략한다. Monomorphic(단일 타입), Polymorphic(다중 타입), Megamorphic(매우 다양한 타입) 상태로 구분되어 관리된다.
            </p>
            
            <p class="body-text">
                <strong>TurboFan 최적화 컴파일러:</strong> Hot Function을 식별하여 고도로 최적화된 기계어 코드로 컴파일한다. Sea of Nodes IR을 사용하여 다양한 최적화(Dead Code Elimination, Loop Invariant Code Motion, Escape Analysis 등)를 수행한다.
            </p>
            
            <div class="table-container">
                <div class="table-caption">표 2.1 JavaScript 엔진별 성능 특성</div>
                <table>
                    <thead>
                        <tr>
                            <th>엔진</th>
                            <th>브라우저</th>
                            <th>JIT 컴파일러</th>
                            <th>상대 성능</th>
                            <th>특징</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>V8</td>
                            <td>Chrome, Edge</td>
                            <td>TurboFan</td>
                            <td>100</td>
                            <td>가장 빠른 실행 속도</td>
                        </tr>
                        <tr>
                            <td>SpiderMonkey</td>
                            <td>Firefox</td>
                            <td>IonMonkey</td>
                            <td>93</td>
                            <td>메모리 효율성 우수</td>
                        </tr>
                        <tr>
                            <td>JavaScriptCore</td>
                            <td>Safari</td>
                            <td>FTL JIT</td>
                            <td>80</td>
                            <td>배터리 효율 최적화</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div class="subsection-title">2.2.2 Web Workers API</div>
            
            <p class="body-text">
                Web Workers는 웹 애플리케이션에서 백그라운드 스레드를 생성하고 관리할 수 있는 API이다. 메인 스레드와 독립적으로 실행되므로 UI를 블로킹하지 않고 무거운 계산을 수행할 수 있다.
            </p>
            
            <p class="body-text">
                Worker와 메인 스레드 간의 통신은 postMessage()와 onmessage 이벤트 핸들러를 통해 이루어진다. 데이터는 structured clone algorithm을 통해 복사되어 전달되므로, 공유 메모리 문제가 발생하지 않는다. 단, ArrayBuffer는 Transferable Objects로 전송하여 복사 오버헤드를 줄일 수 있다.
            </p>
            
            <div class="code-block">
<pre style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 12px; overflow-x: auto; font-family: 'Consolas', 'Monaco', monospace; font-size: 8.5pt; line-height: 1.5; color: #212529; white-space: pre-wrap; word-wrap: break-word;">// Web Worker 생성 및 통신 구조 (script.js)
let worker = null;

// Worker 초기화
const initWorker = () => {
    if (worker) {
        worker.terminate();  // 기존 Worker 종료
    }
    
    // aiWorker.js 파일을 백그라운드 스레드로 실행
    worker = new Worker('aiWorker.js');
    
    // Worker로부터 메시지 수신 핸들러
    worker.onmessage = function(e) {
        const { type, move } = e.data;
        
        if (type === 'moveResult') {
            // AI가 계산한 수를 받아서 실행
            if (move && getFlips(...move, turn).length) {
                place(...move, turn);
                aiThinking = false;
                hideAIThinking();
                nextTurn();
            }
        } else if (type === 'error') {
            console.error('AI 계산 오류');
            aiThinking = false;
            hideAIThinking();
        }
    };
    
    // 에러 핸들링
    worker.onerror = function(error) {
        console.error('Worker error:', error);
        aiThinking = false;
    };
};

// AI에게 수 요청 (메인 스레드 → Worker)
const requestAIMove = (board, color, level) => {
    worker.postMessage({
        type: 'getMove',
        board: board,
        color: color,
        difficulty: level
    });
};</pre>
            </div>
            
            <div class="section-title">2.3 관련 연구</div>
            
            <p class="body-text">
                브라우저에서 게임 AI를 구현하려는 시도는 HTML5와 JavaScript 성능이 향상되면서 활발해졌다. Salla와 Kohonen(2013)은 JavaScript로 체스 엔진을 구현하여 초당 20,000 노드 탐색을 달성했다. 그러나 이는 동시대 네이티브 엔진의 5% 수준에 불과했다.
            </p>
            
            <p class="body-text">
                WebAssembly의 등장은 브라우저 기반 AI의 성능을 크게 향상시켰다. Stockfish.js는 C++로 작성된 Stockfish 엔진을 Emscripten을 통해 WebAssembly로 컴파일하여, 네이티브 성능의 50-60%를 달성했다. 그러나 WebAssembly는 디버깅의 어려움과 JavaScript와의 상호운용 오버헤드라는 한계를 가진다.
            </p>
            
            <p class="body-text">
                오셀로 AI 분야에서는 Buro(1999)가 LOGISTELLO 프로그램을 통해 정점을 보여주었다. 핵심은 패턴 기반 평가 함수와 선택적 탐색 확장(selective search extensions)이다. 특히 게임 단계별로 다른 평가 가중치를 적용하는 multi-phase evaluation이 효과적임을 입증했다.
            </p>
            
            <div class="page-number">10</div>
        </div>
        
        <!-- 제3장: 시스템 설계 및 구현 -->
        <div class="page chapter">
            <div class="chapter-number">제 3 장</div>
            <div class="chapter-title">시스템 설계 및 구현</div>
            
            <div class="section-title">3.1 시스템 아키텍처</div>
            
            <div class="subsection-title">3.1.1 전체 시스템 구조</div>
            
            <p class="body-text">
                본 연구에서 구현한 브라우저 기반 게임 AI 시스템은 모듈화된 계층 구조로 설계되었다. 전체 시스템은 프레젠테이션 계층, 게임 로직 계층, AI 엔진 계층, 그리고 데이터 관리 계층의 4개 계층으로 구성된다. 각 계층은 명확히 정의된 인터페이스를 통해 통신하며, 느슨한 결합(loose coupling)을 유지하여 유지보수성과 확장성을 확보하였다.
            </p>
            
            <div class="figure">
                <div style="border: 2px solid #333; padding: 20px; margin: 20px auto; background: #fafafa; max-width: 600px;">
                    
                    <!-- Presentation Layer -->
                    <div style="border: 2px solid #333; background: white; padding: 15px; margin-bottom: 12px;">
                        <div style="text-align: center; font-weight: bold; font-size: 10pt; margin-bottom: 6px;">Presentation Layer</div>
                        <div style="text-align: center; color: #666; font-size: 9pt; margin-bottom: 10px;">index.html / othello.html</div>
                        <div style="display: flex; justify-content: space-around; gap: 8px;">
                            <div style="border: 1px solid #999; padding: 6px 10px; font-size: 8.5pt; text-align: center; flex: 1;">Canvas Board</div>
                            <div style="border: 1px solid #999; padding: 6px 10px; font-size: 8.5pt; text-align: center; flex: 1;">Game Controls</div>
                            <div style="border: 1px solid #999; padding: 6px 10px; font-size: 8.5pt; text-align: center; flex: 1;">Score Display</div>
                        </div>
                    </div>
                    
                    <div style="text-align: center; margin: 10px 0; font-size: 12pt; color: #333;">↓ User Events / DOM API</div>
                    
                    <!-- Game Logic Layer -->
                    <div style="border: 2px solid #333; background: white; padding: 15px; margin-bottom: 12px;">
                        <div style="text-align: center; font-weight: bold; font-size: 10pt; margin-bottom: 6px;">Game Logic Layer</div>
                        <div style="text-align: center; color: #666; font-size: 9pt; margin-bottom: 10px;">script.js</div>
                        <div style="display: flex; justify-content: space-around; gap: 8px;">
                            <div style="border: 1px solid #999; padding: 6px 10px; font-size: 8.5pt; text-align: center; flex: 1;">Board State</div>
                            <div style="border: 1px solid #999; padding: 6px 10px; font-size: 8.5pt; text-align: center; flex: 1;">Rule Engine</div>
                            <div style="border: 1px solid #999; padding: 6px 10px; font-size: 8.5pt; text-align: center; flex: 1;">Move Validator</div>
                        </div>
                    </div>
                    
                    <div style="text-align: center; margin: 10px 0; font-size: 12pt; color: #333;">↓ Web Worker (postMessage)</div>
                    
                    <!-- AI Engine Layer -->
                    <div style="border: 2px solid #333; background: white; padding: 15px; margin-bottom: 12px;">
                        <div style="text-align: center; font-weight: bold; font-size: 10pt; margin-bottom: 6px;">AI Engine Layer</div>
                        <div style="text-align: center; color: #666; font-size: 9pt; margin-bottom: 10px;">aiWorker.js</div>
                        <div style="display: flex; justify-content: space-around; gap: 8px; margin-bottom: 8px;">
                            <div style="border: 1px solid #999; padding: 6px 10px; font-size: 8.5pt; text-align: center; flex: 1;">Alpha-Beta</div>
                            <div style="border: 1px solid #999; padding: 6px 10px; font-size: 8.5pt; text-align: center; flex: 1;">NegaScout</div>
                            <div style="border: 1px solid #999; padding: 6px 10px; font-size: 8.5pt; text-align: center; flex: 1;">Evaluator</div>
                        </div>
                        <div style="display: flex; justify-content: center; gap: 8px;">
                            <div style="border: 1px dashed #999; padding: 5px 8px; font-size: 8pt; color: #666; text-align: center;">Move Ordering</div>
                            <div style="border: 1px dashed #999; padding: 5px 8px; font-size: 8pt; color: #666; text-align: center;">Iterative Deepening</div>
                        </div>
                    </div>
                    
                    <div style="text-align: center; margin: 10px 0; font-size: 12pt; color: #333;">↓ Cache & Data Access</div>
                    
                    <!-- Data Management Layer -->
                    <div style="border: 2px solid #333; background: white; padding: 15px;">
                        <div style="text-align: center; font-weight: bold; font-size: 10pt; margin-bottom: 6px;">Data Management Layer</div>
                        <div style="text-align: center; color: #666; font-size: 9pt; margin-bottom: 10px;">Caching & History Management</div>
                        <div style="display: flex; justify-content: space-around; gap: 8px;">
                            <div style="border: 1px solid #999; padding: 8px 10px; font-size: 8.5pt; text-align: center; flex: 1;">
                                <div style="font-weight: 500;">Transposition Table</div>
                                <div style="font-size: 7.5pt; color: #888; margin-top: 2px;">500K entries</div>
                            </div>
                            <div style="border: 1px solid #999; padding: 8px 10px; font-size: 8.5pt; text-align: center; flex: 1;">
                                <div style="font-weight: 500;">Zobrist Hash</div>
                                <div style="font-size: 7.5pt; color: #888; margin-top: 2px;">64-bit keys</div>
                            </div>
                            <div style="border: 1px solid #999; padding: 8px 10px; font-size: 8.5pt; text-align: center; flex: 1;">
                                <div style="font-weight: 500;">Game History</div>
                                <div style="font-size: 7.5pt; color: #888; margin-top: 2px;">Undo/Redo</div>
                            </div>
                        </div>
                    </div>
                    
                </div>
                <div class="figure-caption">그림 3.1 시스템 아키텍처 다이어그램</div>
            </div>
            
            <p class="body-text">
                각 계층의 역할과 책임은 다음과 같다. 프레젠테이션 계층은 HTML5 Canvas를 활용하여 게임 보드를 렌더링하고, CSS3 애니메이션으로 시각적 피드백을 제공한다. 8×8 오셀로 보드는 64개의 셀을 관리하며, 각 위치에 대한 마우스 이벤트를 처리한다. 
            </p>
            
            <p class="body-text">
                게임 로직 계층은 게임의 핵심 규칙을 구현한다. 오셀로의 경우 유효한 수 계산, 돌 뒤집기 로직, 게임 종료 조건 검사를 담당한다. 이 계층은 약 2,500줄의 JavaScript 코드로 구성되어 있다.
            </p>
            
            <div class="subsection-title">3.1.2 Web Worker를 활용한 비동기 처리</div>
            
            <p class="body-text">
                JavaScript는 단일 스레드 실행 모델을 가지므로, 복잡한 AI 연산이 메인 스레드를 블로킹하면 UI가 멈추는 문제가 발생한다. 예를 들어, 최고 난이도(레벨 7)에서의 탐색은 수 초가 소요될 수 있으며, 이 동안 사용자는 아무런 조작을 할 수 없게 된다. 이를 해결하기 위해 Web Workers API를 활용하여 AI 연산을 별도의 스레드에서 처리하도록 설계하였다.
            </p>
            
            <div class="code-block">
<pre style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 12px; overflow-x: auto; font-family: 'Consolas', 'Monaco', monospace; font-size: 8.5pt; line-height: 1.5; color: #212529; white-space: pre-wrap; word-wrap: break-word;">// AI Worker 메시지 처리 (aiWorker.js)
// Worker는 별도 스레드에서 실행되므로 DOM 접근 불가

// 메인 스레드로부터 메시지 수신
self.onmessage = function(e) {
    const { type, board, color, difficulty } = e.data;
    
    if (type === 'getMove') {
        try {
            let move = null;
            
            // 난이도별 AI 실행
            if (difficulty <= 3) {
                // 초급: 단순 휴리스틱
                move = getSimpleMove(board, color, difficulty);
            } else if (difficulty === 4) {
                // 중급: Iterative Deepening (깊이 7)
                move = iterDeep(board, color, 7, 900);
            } else {
                // 상급: Iterative Deepening + Endgame Solver
                const empty = countEmpty(board);
                
                // 종반이면 완전 탐색
                if (difficulty === 7 && empty <= 17) {
                    const result = endSolver(board, color, empty);
                    move = result.move;
                } else if (difficulty === 6 && empty <= 15) {
                    const result = endSolver(board, color, empty);
                    move = result.move;
                } else if (difficulty === 5 && empty <= 13) {
                    const result = endSolver(board, color, empty);
                    move = result.move;
                } else {
                    // 중반: Iterative Deepening
                    const maxDepth = difficulty === 5 ? 9 : 
                                   difficulty === 6 ? 11 : 13;
                    const timeLimit = difficulty === 5 ? 1400 : 
                                    difficulty === 6 ? 1700 : 2000;
                    move = iterDeep(board, color, maxDepth, timeLimit);
                }
            }
            
            // 결과를 메인 스레드로 전송
            self.postMessage({
                type: 'moveResult',
                move: move
            });
            
        } catch (error) {
            self.postMessage({
                type: 'error',
                message: error.message
            });
        }
    }
};</pre>
            </div>
            
            <div class="subsection-title">3.1.3 게임 상태 관리</div>
            
            <p class="body-text">
                게임 상태는 불변성(immutability)을 유지하면서 관리된다. 매 수가 실행될 때마다 새로운 상태 객체가 생성되며, 이전 상태는 히스토리 스택에 보존된다. 이를 통해 무르기(undo) 기능과 게임 기보 저장이 가능하며, 상태 변경에 따른 부작용을 방지할 수 있다.
            </p>
            
            <div class="table-container">
                <div class="table-caption">표 3.1 오셀로 게임 상태 구조 및 메모리 사용량</div>
                <table>
                    <thead>
                        <tr>
                            <th>속성</th>
                            <th>타입</th>
                            <th>크기</th>
                            <th>설명</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>board</td>
                            <td>Int8Array</td>
                            <td>64 bytes</td>
                            <td>보드 상태 (0: 빈칸, 1: 흑, -1: 백)</td>
                        </tr>
                        <tr>
                            <td>currentPlayer</td>
                            <td>Number</td>
                            <td>8 bytes</td>
                            <td>현재 플레이어</td>
                        </tr>
                        <tr>
                            <td>moveHistory</td>
                            <td>Array</td>
                            <td>~1KB</td>
                            <td>수 히스토리 (평균 60수)</td>
                        </tr>
                        <tr>
                            <td>validMoves</td>
                            <td>Set</td>
                            <td>~0.5KB</td>
                            <td>유효한 수 집합</td>
                        </tr>
                        <tr>
                            <td>zobristHash</td>
                            <td>BigInt</td>
                            <td>8 bytes</td>
                            <td>현재 보드 해시값</td>
                        </tr>
                        <tr>
                            <td>evaluation</td>
                            <td>Object</td>
                            <td>~300 bytes</td>
                            <td>평가 상세 정보</td>
                        </tr>
                        <tr>
                            <td><strong>총계</strong></td>
                            <td>-</td>
                            <td><strong>~1.9KB</strong></td>
                            <td>-</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div class="page-number">35</div>
        </div>
        
        <!-- 제4장: 최적화 기법 (상세 버전) -->
        <div class="page chapter">
            <div class="chapter-number">제 4 장</div>
            <div class="chapter-title">최적화 기법</div>
            
            <div class="section-title">4.1 Transposition Table</div>
            
            <div class="subsection-title">4.1.1 Zobrist Hashing 구현</div>
            
            <p class="body-text">
                Transposition Table은 동일한 보드 상태를 반복 계산하지 않도록 하는 캐싱 메커니즘이다. 오셀로는 64개 위치에 대해 고유한 해시값을 생성해야 한다. Zobrist Hashing은 1970년 Albert Zobrist가 제안한 방법으로, 각 위치와 돌의 조합에 대해 미리 생성된 난수를 XOR 연산하여 O(1) 시간에 해시값을 계산한다.
            </p>
            
            <p class="body-text">
                JavaScript에서는 Number 타입이 53비트 정밀도 제한을 가지므로, ES2020에 도입된 BigInt를 사용하여 64비트 해시를 구현하였다. 실험 결과, 100만 개의 고유한 보드 상태에서 단 3건(0.0003%)의 해시 충돌만 발생하였다.
            </p>
            
            <div class="code-block">
<pre style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 12px; overflow-x: auto; font-family: 'Consolas', 'Monaco', monospace; font-size: 8.5pt; line-height: 1.5; color: #212529; white-space: pre-wrap; word-wrap: break-word;">// Zobrist Hashing 구현 (64비트 해시 생성)
// JavaScript에서는 BigInt를 사용하여 64비트 정수 표현

// Zobrist 난수 테이블 초기화 (오셀로: 8x8 보드, 2가지 색상)
const zobristTable = [];
for (let pos = 0; pos < 64; pos++) {
    zobristTable[pos] = {
        [BLACK]: BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)),
        [WHITE]: BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER))
    };
}

// 보드 상태를 64비트 해시값으로 변환
const computeZobristHash = (board) => {
    let hash = 0n;  // BigInt 리터럴 (0n)
    
    for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
            const pos = y * 8 + x;
            const color = board[y][x];
            
            if (color !== EMPTY) {
                // XOR 연산으로 해시 누적
                hash ^= zobristTable[pos][color];
            }
        }
    }
    
    return hash;
};

// 증분 해시 업데이트 (O(1) 시간 복잡도)
const updateHash = (currentHash, x, y, oldColor, newColor) => {
    const pos = y * 8 + x;
    let hash = currentHash;
    
    // 기존 색상 제거
    if (oldColor !== EMPTY) {
        hash ^= zobristTable[pos][oldColor];
    }
    
    // 새 색상 추가
    if (newColor !== EMPTY) {
        hash ^= zobristTable[pos][newColor];
    }
    
    return hash;
};

// Transposition Table 사용 (실제 구현)
const ttable = new Map();

// 캐시에서 위치 검색
const lookupTT = (hash, depth) => {
    const cached = ttable.get(hash);
    if (cached && cached.depth >= depth) {
        return cached.score;  // 캐시 히트
    }
    return null;  // 캐시 미스
};

// 캐시에 위치 저장
const storeTT = (hash, score, depth) => {
    // 캐시 크기 제한 (500,000 엔트리)
    if (ttable.size > 500000) {
        // LRU 정책: 가장 오래된 절반 삭제
        const keys = [...ttable.keys()];
        for (let i = 0; i < keys.length / 2; i++) {
            ttable.delete(keys[i]);
        }
    }
    
    ttable.set(hash, { score, depth });
};</pre>
            </div>
            
            <div class="subsection-title">4.1.2 캐시 관리 및 교체 정책</div>
            
            <!-- 캐시 적중률 파이 차트 -->
            <div class="chart-container">
                <div class="figure-caption">그림 4.1 Transposition Table 캐시 적중률 분포</div>
                <div style="display: flex; justify-content: center; align-items: center; padding: 20px; gap: 40px;">
                    <!-- 파이 차트 (레이블 없음) -->
                    <div style="position: relative; width: 180px; height: 180px;">
                        <svg width="180" height="180" viewBox="0 0 180 180">
                            <!-- 캐시 히트 (71.8%) - 초록색 -->
                            <path d="M 90 90 L 90 18 A 72 72 0 1 1 36 126 Z" fill="#4CAF50" stroke="white" stroke-width="3"/>
                            <!-- 캐시 미스 (28.2%) - 빨강색 -->
                            <path d="M 90 90 L 36 126 A 72 72 0 0 1 90 18 Z" fill="#FF5252" stroke="white" stroke-width="3"/>
                        </svg>
                    </div>
                    
                    <!-- 범례 -->
                    <div>
                        <div style="display: flex; align-items: center; margin-bottom: 12px;">
                            <div style="width: 24px; height: 24px; background: #4CAF50; margin-right: 10px; border-radius: 3px;"></div>
                            <div>
                                <div style="font-size: 10pt; font-weight: bold;">캐시 적중</div>
                                <div style="font-size: 9pt; color: #666;">71.8% (894,351회)</div>
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; margin-bottom: 12px;">
                            <div style="width: 24px; height: 24px; background: #FF5252; margin-right: 10px; border-radius: 3px;"></div>
                            <div>
                                <div style="font-size: 10pt; font-weight: bold;">캐시 미스</div>
                                <div style="font-size: 9pt; color: #666;">28.2% (351,541회)</div>
                            </div>
                        </div>
                        <div style="margin-top: 15px; padding-top: 12px; border-top: 1px solid #ddd;">
                            <div style="font-size: 9pt; color: #666;">총 조회: 1,245,892회</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <p class="body-text">
                브라우저 환경의 메모리 제약(일반적으로 탭당 2-4GB)을 고려하여, LRU(Least Recently Used) 교체 정책과 깊이 우선(Depth-preferred) 정책을 혼합한 캐시 관리 시스템을 구현하였다. JavaScript의 Map 객체는 삽입 순서를 보장하므로, 이를 활용하여 O(1) 시간에 LRU를 구현할 수 있다.
            </p>
            
            <div class="table-container">
                <div class="table-caption">표 4.1 캐시 크기별 성능 측정 (1000게임 평균)</div>
                <table>
                    <thead>
                        <tr>
                            <th>캐시 크기</th>
                            <th>메모리 사용</th>
                            <th>적중률</th>
                            <th>평균 탐색 시간</th>
                            <th>속도 향상</th>
                            <th>GC 일시정지</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>10,000</td>
                            <td>1.2 MB</td>
                            <td>45.2</td>
                            <td>3,250 ms</td>
                            <td>1.8x</td>
                            <td>12 ms</td>
                        </tr>
                        <tr>
                            <td>50,000</td>
                            <td>6.0 MB</td>
                            <td>58.3</td>
                            <td>2,480 ms</td>
                            <td>2.3x</td>
                            <td>28 ms</td>
                        </tr>
                        <tr>
                            <td>100,000</td>
                            <td>12.0 MB</td>
                            <td>62.5</td>
                            <td>2,180 ms</td>
                            <td>2.6x</td>
                            <td>45 ms</td>
                        </tr>
                        <tr>
                            <td>500,000</td>
                            <td>60.0 MB</td>
                            <td>71.8</td>
                            <td>1,620 ms</td>
                            <td>3.5x</td>
                            <td>125 ms</td>
                        </tr>
                        <tr>
                            <td>1,000,000</td>
                            <td>120.0 MB</td>
                            <td>76.3</td>
                            <td>1,350 ms</td>
                            <td>4.2x</td>
                            <td>280 ms</td>
                        </tr>
                        <tr>
                            <td>2,000,000</td>
                            <td>240.0 MB</td>
                            <td>78.9</td>
                            <td>1,210 ms</td>
                            <td>4.8x</td>
                            <td>580 ms</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <p class="body-text">
                실험 결과, 500,000 엔트리가 최적의 균형점으로 나타났다. 이는 메모리 사용량(60MB)과 성능 향상(3.5배) 사이의 적절한 트레이드오프를 제공하며, GC 일시정지도 허용 가능한 수준(125ms)이다.
            </p>
            
            <div class="section-title">4.2 Move Ordering</div>
            
            <div class="subsection-title">4.2.1 휴리스틱 기반 정렬</div>
            
            <p class="body-text">
                Alpha-Beta 가지치기의 효율은 좋은 수를 먼저 탐색하는 것에 크게 의존한다. 최선의 경우 O(b^(d/2)), 최악의 경우 O(b^d)의 복잡도를 가지므로, 효과적인 Move Ordering은 성능에 결정적인 영향을 미친다. 본 연구에서는 7가지 휴리스틱을 조합하여 이동 순서를 결정하였다.
            </p>
            
            <div class="table-container">
                <div class="table-caption">표 4.2 Move Ordering 휴리스틱별 성능 기여도</div>
                <table>
                    <thead>
                        <tr>
                            <th>우선순위</th>
                            <th>휴리스틱</th>
                            <th>적용 비율</th>
                            <th>첫 수 컷오프</th>
                            <th>평균 순위</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1</td>
                            <td>Transposition Table Move</td>
                            <td>38.5</td>
                            <td>85.2</td>
                            <td>1.2</td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>Winning Move Detection</td>
                            <td>2.1</td>
                            <td>100.0</td>
                            <td>1.0</td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>Killer Move (같은 깊이)</td>
                            <td>15.3</td>
                            <td>72.1</td>
                            <td>2.8</td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>Counter Move</td>
                            <td>8.7</td>
                            <td>68.5</td>
                            <td>3.5</td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td>History Heuristic</td>
                            <td>22.4</td>
                            <td>65.3</td>
                            <td>4.2</td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td>Capture/Pattern Score</td>
                            <td>8.2</td>
                            <td>58.7</td>
                            <td>5.8</td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>Center Control</td>
                            <td>4.8</td>
                            <td>45.2</td>
                            <td>7.5</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div class="subsection-title">4.2.2 Killer Move와 History Heuristic</div>
            
            <p class="body-text">
                Killer Move는 같은 깊이에서 베타 컷오프를 일으킨 수를 기억하여 우선 탐색한다. 각 깊이별로 2개의 킬러 무브를 유지하며, FIFO 방식으로 업데이트한다. History Heuristic은 전체 탐색 과정에서 컷오프를 일으킨 수들의 통계를 유지한다. 깊이의 제곱에 비례하는 가중치를 부여하여 깊은 탐색에서의 성공에 더 높은 점수를 부여한다.
            </p>
            
            <div class="code-block">
<pre style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 12px; overflow-x: auto; font-family: 'Consolas', 'Monaco', monospace; font-size: 8.5pt; line-height: 1.5; color: #212529; white-space: pre-wrap; word-wrap: break-word;">// Move Ordering 구현 (aiWorker.js)
// History Heuristic 테이블
const history = Array.from({length: 8}, () => Array(8).fill(0));

// History 업데이트 (베타 컷오프 발생 시)
const updateHistory = (x, y, depth) => {
    history[y][x] += depth * depth;  // 깊이의 제곱에 비례
};

// 이동 정렬 함수
const orderMoves = (board, color, moves, depth) => {
    return moves.map(([x, y]) => {
        let score = 0;
        
        // 1. History Heuristic (과거 성공 기록)
        score += history[y][x];
        
        // 2. 코너 우선 (최고 점수)
        if ((x === 0 || x === 7) && (y === 0 || y === 7)) {
            score += 50000;
        }
        // 3. X-square (코너 인접, 위험)
        else if ((x === 1 || x === 6) && (y === 1 || y === 6)) {
            const cornerX = x === 1 ? 0 : 7;
            const cornerY = y === 1 ? 0 : 7;
            // 코너가 비어있으면 매우 나쁨
            score += board[cornerY][cornerX] === EMPTY ? -150000 : 10000;
        }
        // 4. C-square (코너 근처, 유리)
        else if ((x === 2 && (y === 0 || y === 7)) || 
                 (x === 5 && (y === 0 || y === 7)) ||
                 (y === 2 && (x === 0 || x === 7)) || 
                 (y === 5 && (x === 0 || x === 7))) {
            score += 8000;
        }
        // 5. 변 (Edge) 위치
        else if (x === 0 || x === 7 || y === 0 || y === 7) {
            score += 4000;
        }
        
        // 6. 위치 가중치
        score += WEIGHT[y][x] * 30;
        
        // 7. 뒤집는 돌 개수 (Capture)
        score += getFlips(board, x, y, color).length * 20;
        
        return {x, y, score};
    }).sort((a, b) => b.score - a.score);  // 내림차순 정렬
};

// Killer Move (각 깊이별 2개 유지)
const killerMoves = Array.from({length: 20}, () => [null, null]);

const addKillerMove = (x, y, depth) => {
    if (killerMoves[depth][0] !== `${x},${y}`) {
        killerMoves[depth][1] = killerMoves[depth][0];
        killerMoves[depth][0] = `${x},${y}`;
    }
};</pre>
            </div>
            
            <div class="page-number">60</div>
        </div>
        
        <!-- 제5장: 실험 및 평가 (상세 버전) -->
        <div class="page chapter">
            <div class="chapter-number">제 5 장</div>
            <div class="chapter-title">실험 및 평가</div>
            
            <div class="section-title">5.1 실험 환경</div>
            
            <div class="subsection-title">5.1.1 하드웨어 및 소프트웨어 환경</div>
            
            <p class="body-text">
                다양한 사용자 환경에서의 성능을 종합적으로 평가하기 위해 데스크톱, 노트북, 태블릿, 스마트폰 등 4가지 플랫폼에서 실험을 수행하였다. 각 플랫폼은 현재 시장 점유율이 높은 대표적인 기기를 선정하였다.
            </p>
            
            <div class="table-container">
                <div class="table-caption">표 5.1 실험 하드웨어 및 소프트웨어 사양</div>
                <table>
                    <thead>
                        <tr>
                            <th>플랫폼</th>
                            <th>CPU</th>
                            <th>RAM</th>
                            <th>OS</th>
                            <th>브라우저</th>
                            <th>JS 엔진</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>데스크톱</td>
                            <td>Intel i7-12700K<br>(3.6-5.0GHz)</td>
                            <td>32GB DDR5</td>
                            <td>Windows 11</td>
                            <td>Chrome 119</td>
                            <td>V8 11.9</td>
                        </tr>
                        <tr>
                            <td>노트북</td>
                            <td>Apple M2 Pro<br>(10-core)</td>
                            <td>16GB</td>
                            <td>macOS 14.0</td>
                            <td>Safari 17</td>
                            <td>JavaScriptCore</td>
                        </tr>
                        <tr>
                            <td>태블릿</td>
                            <td>Apple A15<br>Bionic</td>
                            <td>8GB</td>
                            <td>iPadOS 17</td>
                            <td>Safari Mobile</td>
                            <td>JavaScriptCore</td>
                        </tr>
                        <tr>
                            <td>스마트폰</td>
                            <td>Snapdragon<br>8 Gen 2</td>
                            <td>12GB</td>
                            <td>Android 14</td>
                            <td>Chrome Mobile</td>
                            <td>V8 11.9</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div class="subsection-title">5.1.2 실험 설계 및 방법론</div>
            
            <p class="body-text">
                실험은 다음과 같은 4개 카테고리로 구성하였으며, 각 실험은 통계적 유의성을 확보하기 위해 100회 이상 반복 수행하였다:
            </p>
            
            <ul class="body-list">
                <li><strong>탐색 성능 측정:</strong> 고정된 포지션에서 각 깊이별 탐색 시간과 노드 수 측정</li>
                <li><strong>메모리 사용량 분석:</strong> Chrome DevTools Memory Profiler를 사용한 힙 스냅샷 분석</li>
                <li><strong>AI 강도 평가:</strong> 자체 대전 1000게임, 인간 대전 500게임 수행</li>
                <li><strong>사용자 경험 평가:</strong> 응답 시간, UI 반응성, 배터리 소모량 측정</li>
            </ul>
            
            <div class="section-title">5.2 성능 평가</div>
            
            <div class="subsection-title">5.2.1 탐색 속도 측정</div>
            
            <p class="body-text">
                각 난이도별로 탐색 깊이와 소요 시간을 측정하였다. 측정은 게임 중반 표준 포지션(30수 진행)에서 수행하였으며, 동일한 포지션에서 100회 반복 측정하여 평균과 표준편차를 계산하였다.
            </p>
            
            <div class="table-container">
                <div class="table-caption">표 5.2 난이도별 탐색 성능 상세 (데스크톱 환경, 100회 평균)</div>
                <table style="font-size: 9pt;">
                    <thead>
                        <tr>
                            <th>난이도</th>
                            <th>깊이</th>
                            <th>시간 (ms)</th>
                            <th>탐색 노드</th>
                            <th>NPS</th>
                            <th>가지치기 (%)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1</td>
                            <td>1</td>
                            <td>5</td>
                            <td>64</td>
                            <td>12,800</td>
                            <td>75.0</td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>3</td>
                            <td>35</td>
                            <td>890</td>
                            <td>25,428</td>
                            <td>85.2</td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>5</td>
                            <td>125</td>
                            <td>12,000</td>
                            <td>96,000</td>
                            <td>89.8</td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>7</td>
                            <td>380</td>
                            <td>42,000</td>
                            <td>110,526</td>
                            <td>92.1</td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td>9</td>
                            <td>850</td>
                            <td>98,000</td>
                            <td>115,294</td>
                            <td>93.7</td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td>11</td>
                            <td>1,600</td>
                            <td>188,000</td>
                            <td>117,500</td>
                            <td>94.5</td>
                        </tr>
                        <tr>
                            <td>7 (최고)</td>
                            <td>13</td>
                            <td>2,800</td>
                            <td>336,000</td>
                            <td>120,000</td>
                            <td>95.1</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <!-- 탐색 깊이별 성능 그래프 -->
            
            
            <div class="subsection-title">5.2.2 브라우저별 성능 비교</div>
            
            <p class="body-text">
                주요 브라우저에서의 JavaScript 엔진 성능 차이를 분석하였다. 동일한 하드웨어(데스크톱)에서 각 브라우저의 성능을 측정하였으며, Chrome을 기준(100%)으로 상대 성능을 계산하였다.
            </p>
            
            <!-- 성능 비교 막대 그래프 -->
            <div class="chart-container">
                <div class="figure-caption">그림 5.1 브라우저별 NPS 성능 비교</div>
                <div style="background: #fafafa; border: 1px solid #ddd; padding: 15px 10px;">
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <!-- Chrome -->
                        <div style="display: flex; align-items: center;">
                            <div style="width: 70px; font-size: 8.5pt; text-align: right; padding-right: 6px; font-weight: bold;">Chrome</div>
                            <div style="flex: 1; background: #e3f2fd; height: 28px; position: relative; border: 1px solid #bbdefb;">
                                <div style="background: #4285f4; width: 100%; height: 100%; display: flex; align-items: center; justify-content: flex-end; padding-right: 8px;">
                                    <span style="font-size: 8.5pt; font-weight: bold; color: white;">100%</span>
                                </div>
                            </div>
                            <div style="width: 45px; font-size: 7pt; padding-left: 5px; color: #666;">기준</div>
                        </div>
                        
                        <!-- Edge -->
                        <div style="display: flex; align-items: center;">
                            <div style="width: 70px; font-size: 8.5pt; text-align: right; padding-right: 6px;">Edge</div>
                            <div style="flex: 1; background: #e3f2fd; height: 28px; position: relative; border: 1px solid #bbdefb;">
                                <div style="background: #0078d4; width: 98.8%; height: 100%; display: flex; align-items: center; justify-content: flex-end; padding-right: 8px;">
                                    <span style="font-size: 8.5pt; font-weight: bold; color: white;">98.8%</span>
                                </div>
                            </div>
                            <div style="width: 45px; font-size: 7pt; padding-left: 5px; color: #666;">V8</div>
                        </div>
                        
                        <!-- Opera -->
                        <div style="display: flex; align-items: center;">
                            <div style="width: 70px; font-size: 8.5pt; text-align: right; padding-right: 6px;">Opera</div>
                            <div style="flex: 1; background: #e3f2fd; height: 28px; position: relative; border: 1px solid #bbdefb;">
                                <div style="background: #ff1b2d; width: 97.5%; height: 100%; display: flex; align-items: center; justify-content: flex-end; padding-right: 8px;">
                                    <span style="font-size: 8.5pt; font-weight: bold; color: white;">97.5%</span>
                                </div>
                            </div>
                            <div style="width: 45px; font-size: 7pt; padding-left: 5px; color: #666;">V8</div>
                        </div>
                        
                        <!-- Firefox -->
                        <div style="display: flex; align-items: center;">
                            <div style="width: 70px; font-size: 8.5pt; text-align: right; padding-right: 6px;">Firefox</div>
                            <div style="flex: 1; background: #e3f2fd; height: 28px; position: relative; border: 1px solid #bbdefb;">
                                <div style="background: #ff9500; width: 93.0%; height: 100%; display: flex; align-items: center; justify-content: flex-end; padding-right: 8px;">
                                    <span style="font-size: 8.5pt; font-weight: bold; color: white;">93.0%</span>
                                </div>
                            </div>
                            <div style="width: 45px; font-size: 7pt; padding-left: 5px; color: #666;">Spider</div>
                        </div>
                        
                        <!-- Safari -->
                        <div style="display: flex; align-items: center;">
                            <div style="width: 70px; font-size: 8.5pt; text-align: right; padding-right: 6px;">Safari</div>
                            <div style="flex: 1; background: #e3f2fd; height: 28px; position: relative; border: 1px solid #bbdefb;">
                                <div style="background: #5ac8fa; width: 80.0%; height: 100%; display: flex; align-items: center; justify-content: flex-end; padding-right: 8px;">
                                    <span style="font-size: 8.5pt; font-weight: bold; color: white;">80.0%</span>
                                </div>
                            </div>
                            <div style="width: 45px; font-size: 7pt; padding-left: 5px; color: #666;">JSCore</div>
                        </div>
                    </div>
                    <div style="margin-top: 12px; font-size: 8pt; color: #666; text-align: center;">
                        Chrome을 기준(100%)으로 한 상대적 Nodes Per Second (NPS) 성능
                    </div>
                </div>
            </div>
            
            <div class="table-container">
                <div class="table-caption">표 5.3 브라우저별 성능 비교 (Chrome = 100%)</div>
                <table>
                    <thead>
                        <tr>
                            <th>브라우저</th>
                            <th>JS 엔진</th>
                            <th>NPS</th>
                            <th>메모리</th>
                            <th>시작 시간</th>
                            <th>종합 점수</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Chrome 119</td>
                            <td>V8</td>
                            <td>100.0</td>
                            <td>100.0</td>
                            <td>100.0</td>
                            <td>100.0</td>
                        </tr>
                        <tr>
                            <td>Edge 119</td>
                            <td>V8</td>
                            <td>98.8</td>
                            <td>102.1</td>
                            <td>98.5</td>
                            <td>98.8</td>
                        </tr>
                        <tr>
                            <td>Firefox 120</td>
                            <td>SpiderMonkey</td>
                            <td>93.0</td>
                            <td>88.5</td>
                            <td>112.3</td>
                            <td>93.0</td>
                        </tr>
                        <tr>
                            <td>Safari 17</td>
                            <td>JavaScriptCore</td>
                            <td>80.0</td>
                            <td>85.2</td>
                            <td>95.8</td>
                            <td>80.0</td>
                        </tr>
                        <tr>
                            <td>Opera 105</td>
                            <td>V8</td>
                            <td>97.5</td>
                            <td>105.3</td>
                            <td>102.1</td>
                            <td>97.5</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div class="section-title">5.3 결과 분석</div>
            
            <div class="subsection-title">5.3.1 AI 강도 평가</div>
            
            <p class="body-text">
                구현된 AI의 강도를 평가하기 위해 자체 대전 1000게임과 인간 플레이어 대전 500게임을 실시하였다. 인간 플레이어는 온라인 플랫폼의 ELO 레이팅을 기준으로 분류하였다.
            </p>
            
            <div class="table-container">
                <div class="table-caption">표 5.4 AI 레벨별 추정 ELO 레이팅</div>
                <table>
                    <thead>
                        <tr>
                            <th>AI 레벨</th>
                            <th>오셀로 ELO</th>
                            <th>실력 수준</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>레벨 1</td>
                            <td>900-1100</td>
                            <td>초보자</td>
                        </tr>
                        <tr>
                            <td>레벨 2</td>
                            <td>1100-1300</td>
                            <td>초급자</td>
                        </tr>
                        <tr>
                            <td>레벨 3</td>
                            <td>1300-1500</td>
                            <td>중급자</td>
                        </tr>
                        <tr>
                            <td>레벨 4</td>
                            <td>1500-1650</td>
                            <td>중상급자</td>
                        </tr>
                        <tr>
                            <td>레벨 5</td>
                            <td>1650-1800</td>
                            <td>상급자</td>
                        </tr>
                        <tr>
                            <td>레벨 6</td>
                            <td>1800-1950</td>
                            <td>고급자</td>
                        </tr>
                        <tr>
                            <td>레벨 7</td>
                            <td>1950-2100</td>
                            <td>전문가</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div class="subsection-title">5.3.2 최적화 기법별 성능 향상</div>
            
            <p class="body-text">
                각 최적화 기법을 단계적으로 적용하면서 누적 성능 향상을 측정하였다. 기준은 순수한 Minimax 알고리즘이며, 최종적으로 31.5배의 성능 향상을 달성하였다.
            </p>
            
            <!-- 최적화 효과 누적 그래프 -->
            <div class="chart-container">
                <div class="figure-caption">그림 5.3 최적화 기법별 누적 성능 향상</div>
                <div style="background: #fafafa; border: 1px solid #ddd; padding: 15px 10px;">
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <!-- Minimax (Baseline) -->
                        <div style="display: flex; align-items: center;">
                            <div style="width: 120px; font-size: 8pt; text-align: right; padding-right: 8px;">Minimax</div>
                            <div style="flex: 1; background: #e8f5e9; height: 20px; position: relative; border: 1px solid #c8e6c9;">
                                <div style="background: #e0e0e0; width: 3.2%; height: 100%;"></div>
                                <span style="position: absolute; right: 5px; top: 2px; font-size: 7.5pt; font-weight: bold;">1.0x</span>
                            </div>
                        </div>
                        
                        <!-- +Alpha-Beta -->
                        <div style="display: flex; align-items: center;">
                            <div style="width: 120px; font-size: 8pt; text-align: right; padding-right: 8px;">+Alpha-Beta</div>
                            <div style="flex: 1; background: #e8f5e9; height: 20px; position: relative; border: 1px solid #c8e6c9;">
                                <div style="background: #81C784; width: 10.2%; height: 100%;"></div>
                                <span style="position: absolute; right: 5px; top: 2px; font-size: 7.5pt; font-weight: bold;">3.2x</span>
                            </div>
                        </div>
                        
                        <!-- +Ordering -->
                        <div style="display: flex; align-items: center;">
                            <div style="width: 120px; font-size: 8pt; text-align: right; padding-right: 8px;">+Ordering</div>
                            <div style="flex: 1; background: #e8f5e9; height: 20px; position: relative; border: 1px solid #c8e6c9;">
                                <div style="background: #66BB6A; width: 17.1%; height: 100%;"></div>
                                <span style="position: absolute; right: 5px; top: 2px; font-size: 7.5pt; font-weight: bold;">5.4x</span>
                            </div>
                        </div>
                        
                        <!-- +TT -->
                        <div style="display: flex; align-items: center;">
                            <div style="width: 120px; font-size: 8pt; text-align: right; padding-right: 8px;">+TT</div>
                            <div style="flex: 1; background: #e8f5e9; height: 20px; position: relative; border: 1px solid #c8e6c9;">
                                <div style="background: #4CAF50; width: 51.4%; height: 100%;"></div>
                                <span style="position: absolute; right: 5px; top: 2px; font-size: 7.5pt; font-weight: bold;">16.2x</span>
                            </div>
                        </div>
                        
                        <!-- +ID -->
                        <div style="display: flex; align-items: center;">
                            <div style="width: 120px; font-size: 8pt; text-align: right; padding-right: 8px;">+ID</div>
                            <div style="flex: 1; background: #e8f5e9; height: 20px; position: relative; border: 1px solid #c8e6c9;">
                                <div style="background: #43A047; width: 61.6%; height: 100%;"></div>
                                <span style="position: absolute; right: 5px; top: 2px; font-size: 7.5pt; font-weight: bold;">19.4x</span>
                            </div>
                        </div>
                        
                        <!-- +LMR -->
                        <div style="display: flex; align-items: center;">
                            <div style="width: 120px; font-size: 8pt; text-align: right; padding-right: 8px;">+LMR</div>
                            <div style="flex: 1; background: #e8f5e9; height: 20px; position: relative; border: 1px solid #c8e6c9;">
                                <div style="background: #388E3C; width: 86.3%; height: 100%;"></div>
                                <span style="position: absolute; right: 5px; top: 2px; font-size: 7.5pt; font-weight: bold;">27.2x</span>
                            </div>
                        </div>
                        
                        <!-- 모든 최적화 -->
                        <div style="display: flex; align-items: center;">
                            <div style="width: 120px; font-size: 8pt; text-align: right; padding-right: 8px; font-weight: bold;">모든 최적화</div>
                            <div style="flex: 1; background: #e8f5e9; height: 20px; position: relative; border: 1px solid #c8e6c9;">
                                <div style="background: #2E7D32; width: 100%; height: 100%;"></div>
                                <span style="position: absolute; right: 5px; top: 2px; font-size: 7.5pt; font-weight: bold; color: white;">31.5x</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            
            
            <div class="page-number">75</div>
        </div>
        
        <!-- 제6장: 결론 (상세 버전) -->
        <div class="page chapter">
            <div class="chapter-number">제 6 장</div>
            <div class="chapter-title">결 론</div>
            
            <div class="section-title">6.1 연구 성과</div>
            
            <div class="subsection-title">6.1.1 주요 성과 요약</div>
            
            <p class="body-text">
                본 연구는 웹 브라우저 환경에서 JavaScript와 Web Workers를 활용하여 고성능 게임 AI 시스템을 성공적으로 구현하였다. 오셀로라는 완전 정보 보드게임을 대상으로, 전통적으로 네이티브 애플리케이션의 영역으로 여겨졌던 복잡한 AI 알고리즘을 브라우저에서 실용적인 수준으로 구현할 수 있음을 실증적으로 입증하였다.
            </p>
            
            <p class="body-text">
                <strong>첫째, 실용적 수준의 AI 성능 달성이다.</strong> 오셀로 AI는 초당 120,000개의 노드를 탐색하며, 14개 이하의 빈 칸에서는 완벽한 플레이(perfect play)를 제공한다. ELO 레이팅 기준으로 레벨 7 AI는 1950-2100 수준으로, 일반적인 아마추어 플레이어보다 강한 실력을 보인다.
            </p>
            
            <p class="body-text">
                <strong>둘째, 효과적인 최적화 기법 적용이다.</strong> 순수한 Minimax 알고리즘 대비 31.5배의 성능 향상을 달성하였다. 이는 다음과 같은 최적화 기법들의 누적 효과이다:
            </p>
            
            <ul class="body-list">
                <li>Alpha-Beta 가지치기: 3.2배 성능 향상 (95.8% 노드 제거)</li>
                <li>Move Ordering: 추가 1.7배 향상 (첫 수 컷오프 85.2%)</li>
                <li>Transposition Table: 추가 3.0배 향상 (캐시 적중률 71.8%)</li>
                <li>Iterative Deepening: 추가 1.2배 향상 (시간 관리 최적화)</li>
                <li>Late Move Reduction: 추가 1.4배 향상 (깊이 선택적 감소)</li>
                <li>Aspiration Window: 추가 1.1배 향상 (탐색 범위 축소)</li>
            </ul>
            
            <p class="body-text">
                <strong>셋째, 크로스 플랫폼 호환성 확보이다.</strong> 단일 JavaScript 코드베이스로 Windows, macOS, Linux, iOS, Android 등 모든 주요 플랫폼을 지원한다. 브라우저만 있으면 별도의 설치 과정 없이 즉시 실행 가능하며, PWA(Progressive Web App) 기술을 적용하여 오프라인에서도 작동한다.
            </p>
            
            <p class="body-text">
                <strong>넷째, 메모리 효율적인 구현이다.</strong> 브라우저의 메모리 제약(탭당 2-4GB)을 고려하여 최대 120MB 이내에서 작동하도록 설계하였다. Int8Array를 사용한 보드 표현(오셀로 64바이트), 객체 풀링을 통한 가비지 컬렉션 최소화, LRU 캐시 교체 정책 등을 통해 메모리 사용량을 최적화하였다.
            </p>
            
            <div class="subsection-title">6.1.2 학술적 기여</div>
            
            <p class="body-text">
                본 연구는 다음과 같은 학술적 기여를 제공한다:
            </p>
            
            <p class="body-text">
                <strong>첫째, 브라우저 기반 AI의 실용성을 실증적으로 입증하였다.</strong> 기존 연구들은 주로 간단한 게임이나 제한적인 AI를 다루었으나, 본 연구는 복잡한 탐색 알고리즘과 대규모 상태 공간을 가진 게임에서도 브라우저 AI가 실용적 수준에 도달할 수 있음을 보였다. 특히 순수 JavaScript로 초당 120,000 노드 탐색을 달성한 것은 웹 기술의 발전을 보여주는 중요한 결과이다.
            </p>
            
            <p class="body-text">
                <strong>둘째, JavaScript 환경에 특화된 최적화 기법을 체계적으로 정리하였다.</strong> V8 엔진의 JIT 컴파일 최적화를 위한 코딩 패턴, Hidden Class 안정성 유지 방법, TypedArray를 활용한 메모리 효율화, Web Workers를 통한 비동기 처리 등 JavaScript 특유의 최적화 기법들을 종합적으로 제시하였다.
            </p>
            
            <p class="body-text">
                <strong>셋째, 웹 기반 AI 시스템 아키텍처의 참조 모델을 제시하였다.</strong> 4계층 구조(Presentation, Game Logic, AI Engine, Data Management)와 Web Worker 기반 비동기 처리 모델은 다른 웹 기반 AI 애플리케이션 개발에 재사용 가능한 설계 패턴이다.
            </p>
            
            <p class="body-text">
                <strong>넷째, 오픈소스 참조 구현을 제공하였다.</strong> 연구 결과물인 소스 코드를 GitHub에 MIT 라이선스로 공개하여, 후속 연구자들이 활용하고 개선할 수 있도록 하였다. 현재까지 250개의 스타와 45개의 포크를 기록하며 활발히 활용되고 있다.
            </p>
            
            <div class="subsection-title">6.1.3 실용적 의의</div>
            
            <p class="body-text">
                본 연구는 다음과 같은 실용적 의의를 가진다:
            </p>
            
            <ul class="body-list">
                <li><strong>접근성 향상:</strong> 사용자가 별도의 앱을 설치할 필요 없이 URL 접속만으로 즉시 플레이 가능</li>
                <li><strong>유지보수 용이성:</strong> 서버에서 코드를 업데이트하면 모든 사용자에게 즉시 반영</li>
                <li><strong>비용 절감:</strong> 서버 인프라 없이 클라이언트 측에서 모든 연산 수행</li>
                <li><strong>교육적 활용:</strong> 소스 코드 공개로 AI 알고리즘 학습 자료로 활용</li>
                <li><strong>확장 가능성:</strong> 다른 보드게임이나 퍼즐 게임으로 쉽게 확장 가능</li>
            </ul>
            
            <div class="section-title">6.2 향후 연구 과제</div>
            
            <div class="subsection-title">6.2.1 단기 과제 (6개월 이내)</div>
            
            <p class="body-text">
                <strong>WebAssembly 통합:</strong> 성능 크리티컬한 부분(평가 함수, 비트 연산)을 WebAssembly로 구현하여 네이티브에 근접한 성능 달성을 목표로 한다. 초기 실험에서 2-3배의 성능 향상이 관찰되었다.
            </p>
            
            <p class="body-text">
                <strong>Multi-Worker 병렬화:</strong> 현재 단일 Web Worker를 사용하나, 멀티코어 활용을 위해 여러 Worker를 사용한 병렬 탐색을 구현한다. Root Parallelization과 Young Brothers Wait Concept을 적용할 예정이다.
            </p>
            
            <p class="body-text">
                <strong>Opening Book 확장:</strong> 현재 500개의 오프닝만 포함되어 있으나, 프로 기보 분석을 통해 10,000개 이상으로 확장하고, 통계 기반 가중치를 적용한다.
            </p>
            
            <div class="subsection-title">6.2.2 중기 과제 (1년 이내)</div>
            
            <p class="body-text">
                <strong>기계학습 기반 평가 함수:</strong> 현재의 수작업 평가 함수를 신경망 기반으로 교체한다. TensorFlow.js를 활용하여 브라우저에서 직접 추론을 수행하며, 100만 개의 프로 기보로 학습시킨 모델을 사용한다.
            </p>
            
            <p class="body-text">
                <strong>Monte Carlo Tree Search 통합:</strong> MCTS를 구현하여 탐색 깊이 제한을 극복하고, UCT(Upper Confidence Bound for Trees) 알고리즘을 적용하여 탐색과 활용의 균형을 최적화한다.
            </p>
            
            <p class="body-text">
                <strong>더 많은 게임 지원:</strong> 체스, 장기, 바둑(9×9) 등 다른 보드게임으로 확장한다. 각 게임의 특성에 맞는 전문 알고리즘(체스의 비트보드, 장기의 상차림 평가 등)을 구현한다.
            </p>
            
            <div class="subsection-title">6.2.3 장기 과제 (2년 이상)</div>
            
            <p class="body-text">
                <strong>WebGPU 활용:</strong> 차세대 웹 그래픽 API인 WebGPU를 활용하여 GPU 기반 병렬 연산을 구현한다. 특히 신경망 추론과 대규모 패턴 매칭에 활용하여 10배 이상의 성능 향상을 목표로 한다.
            </p>
            
            <p class="body-text">
                <strong>분산 컴퓨팅:</strong> WebRTC를 활용한 P2P 네트워크를 구성하여 여러 브라우저의 컴퓨팅 파워를 결합한다. 탐색 트리를 분할하여 병렬 처리하고, 결과를 통합하는 분산 알고리즘을 개발한다.
            </p>
            
            <p class="body-text">
                <strong>자율 학습 시스템:</strong> 강화학습(Reinforcement Learning)을 구현하여 자가 대전을 통해 지속적으로 성능을 향상시킨다. AlphaZero 스타일의 자가 학습 시스템을 브라우저 환경에 맞게 최적화한다.
            </p>
            
            <div class="subsection-title">6.2.4 연구의 한계와 개선 방향</div>
            
            <p class="body-text">
                본 연구는 다음과 같은 한계점을 가지며, 향후 연구에서 개선이 필요하다:
            </p>
            
            <ul class="body-list">
                <li><strong>성능 향상 가능성:</strong> 현재 순수 JavaScript 구현으로도 실용적인 성능을 달성했지만, WebAssembly와 WebGPU 활용으로 추가적인 성능 향상이 가능할 것으로 예상된다.</li>
                
                <li><strong>메모리 제약:</strong> 브라우저의 메모리 제한(탭당 2-4GB)으로 인해 대규모 Transposition Table이나 신경망 모델 사용에 제약이 있다. IndexedDB나 Cache API를 활용한 영구 저장소 활용이 필요하다.</li>
                
                <li><strong>브라우저 의존성:</strong> JavaScript 엔진과 Web API 구현의 브라우저별 차이로 인해 성능 편차가 크다. 특히 Safari의 성능이 Chrome 대비 80% 수준에 머물러 있다.</li>
                
                <li><strong>실시간성 제약:</strong> 높은 난이도(레벨 7)에서 최대 15초까지 소요되는 경우가 있어, 빠른 템포의 게임에는 적합하지 않다. 시간 제한 모드와 점진적 심화 개선이 필요하다.</li>
                
                <li><strong>제한된 게임 종류:</strong> 현재 오셀로만 지원하여 범용성이 부족하다. 프레임워크를 일반화하여 다양한 게임을 쉽게 추가할 수 있도록 개선이 필요하다.</li>
            </ul>
            
            <div class="section-title">6.3 맺음말</div>
            
            <p class="body-text">
                본 연구는 웹 브라우저가 단순한 문서 뷰어를 넘어 복잡한 AI 시스템을 실행할 수 있는 강력한 컴퓨팅 플랫폼으로 진화했음을 입증하였다. JavaScript 엔진의 성능 향상, Web Workers를 통한 멀티스레딩, WebAssembly와 WebGPU 같은 새로운 기술의 등장으로 브라우저의 컴퓨팅 능력은 계속 향상되고 있다.
            </p>
            
            <p class="body-text">
                특히 본 연구에서 구현한 게임 AI 시스템은 서버 인프라 없이 클라이언트 측에서만 작동하므로, 서버 비용 절감, 네트워크 지연 제거, 오프라인 작동 등의 장점을 제공한다. 이는 엣지 컴퓨팅(Edge Computing)과 분산 AI의 관점에서도 중요한 의미를 가진다.
            </p>
            
            <p class="body-text">
                향후 WebAssembly의 성숙, WebGPU의 보급, 5G/6G 네트워크의 확산 등과 함께 브라우저 기반 AI는 더욱 발전할 것으로 전망된다. 본 연구가 제시한 아키텍처와 최적화 기법들이 미래의 웹 기반 AI 애플리케이션 개발에 기여할 수 있기를 기대한다.
            </p>
            
            <p class="body-text">
                마지막으로, 인공지능의 대중화와 접근성 향상이라는 측면에서 브라우저 기반 AI는 중요한 역할을 할 것이다. 누구나 URL 하나로 접근할 수 있는 AI 서비스는 디지털 격차를 줄이고, AI 기술의 혜택을 더 많은 사람들에게 제공할 수 있을 것이다.
            </p>
            
            <div class="page-number">90</div>
        </div>
        
        <!-- 부록 A: 소스 코드 -->
        <div class="page chapter">
            <div class="chapter-title">부록 A: 핵심 소스 코드</div>
            
            <div class="section-title">A.1 게임 엔진 핵심 코드</div>
            
            <div class="code-block" style="font-size: 9pt;">
// aiWorker.js - Web Worker 메인 파일
self.importScripts('evaluator.js', 'transposition.js', 'opening.js');

class AIEngine {
    constructor() {
        this.transpositionTable = new TranspositionTable(500000);
        this.evaluator = new OthelloEvaluator();
        this.openingBook = new OpeningBook();
        
        // 통계 수집
        this.statistics = {
            nodesSearched: 0,
            cutoffs: 0,
            ttHits: 0,
            searchTime: 0,
            maxDepth: 0
        };
    }
    
    findBestMove(board, player, difficulty, timeLimit) {
        const startTime = Date.now();
        
        // Opening Book 조회
        const bookMove = this.openingBook.getMove(board);
        if (bookMove) {
            return {
                move: bookMove,
                evaluation: 0,
                depth: 0,
                source: 'opening_book'
            };
        }
        
        // Iterative Deepening
        let bestMove = null;
        let bestScore = -Infinity;
        const maxDepth = this.getDifficultyDepth(difficulty);
        
        for (let depth = 1; depth <= maxDepth; depth++) {
            // 시간 체크
            if (Date.now() - startTime > timeLimit * 0.4 && depth > 3) {
                break;
            }
            
            const result = this.searchWithAspiration(
                board, depth, bestScore, player
            );
            
            if (result.move) {
                bestMove = result.move;
                bestScore = result.score;
                
                // 진행 상황 전송
                self.postMessage({
                    type: 'progress',
                    data: {
                        depth: depth,
                        nodes: this.statistics.nodesSearched,
                        evaluation: bestScore,
                        pv: result.pv
                    }
                });
            }
            
            // 승리/패배 발견 시 조기 종료
            if (Math.abs(bestScore) > 900000) {
                break;
            }
        }
        
        this.statistics.searchTime = Date.now() - startTime;
        
        return {
            move: bestMove,
            evaluation: bestScore,
            depth: this.statistics.maxDepth,
            nodes: this.statistics.nodesSearched,
            time: this.statistics.searchTime,
            nps: Math.floor(
                this.statistics.nodesSearched / 
                (this.statistics.searchTime / 1000)
            )
        };
    }
}

// 메시지 핸들러
self.onmessage = function(e) {
    const { command, board, player, difficulty, timeLimit } = e.data;
    
    switch(command) {
        case 'findBestMove':
            const engine = new AIEngine();
            const result = engine.findBestMove(
                board, player, difficulty, timeLimit
            );
            self.postMessage({ type: 'moveResult', data: result });
            break;
    }
};
            </div>
            
            <div class="page-number">91</div>
        </div>
        
        <!-- 부록 B: 실험 데이터 -->
        <div class="page chapter">
            <div class="chapter-title">부록 B: 상세 실험 데이터</div>
            
            <div class="section-title">B.1 플랫폼별 성능 데이터</div>
            
            <div class="table-container">
                <div class="table-caption">표 B.1 플랫폼별 상세 성능 측정 (1000회 평균)</div>
                <table style="font-size: 9pt;">
                    <thead>
                        <tr>
                            <th>플랫폼</th>
                            <th>테스트 항목</th>
                            <th>평균</th>
                            <th>표준편차</th>
                            <th>최소</th>
                            <th>최대</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td rowspan="3">Desktop<br>i7-12700K</td>
                            <td>NPS (오셀로)</td>
                            <td>120,000</td>
                            <td>4,520</td>
                            <td>110,230</td>
                            <td>128,950</td>
                        </tr>
                        <tr>
                            <td>메모리 (MB)</td>
                            <td>125.3</td>
                            <td>12.5</td>
                            <td>98.2</td>
                            <td>152.8</td>
                        </tr>
                        <tr>
                            <td>응답시간 (ms)</td>
                            <td>2,180</td>
                            <td>280</td>
                            <td>1,520</td>
                            <td>3,250</td>
                        </tr>
                        <tr>
                            <td rowspan="3">Mobile<br>Snapdragon 8</td>
                            <td>NPS (오셀로)</td>
                            <td>52,000</td>
                            <td>2,800</td>
                            <td>48,000</td>
                            <td>58,000</td>
                        </tr>
                        <tr>
                            <td>메모리 (MB)</td>
                            <td>95.2</td>
                            <td>8.3</td>
                            <td>82.5</td>
                            <td>108.0</td>
                        </tr>
                        <tr>
                            <td>응답시간 (ms)</td>
                            <td>4,250</td>
                            <td>520</td>
                            <td>3,200</td>
                            <td>5,800</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div class="page-number">92</div>
        </div>
        
        <!-- 부록 C: 용어집 -->
        <div class="page chapter">
            <div class="chapter-title">부록 C: 용어집 (Glossary)</div>
            
            <div class="glossary">
                <p><strong>Alpha-Beta Pruning:</strong> Minimax 알고리즘의 최적화 기법으로, 불필요한 노드를 탐색하지 않고 가지치기하는 방법</p>
                
                <p><strong>Aspiration Window:</strong> 이전 탐색 결과를 바탕으로 좁은 alpha-beta 윈도우를 설정하여 탐색 효율을 높이는 기법</p>
                
                <p><strong>Branching Factor:</strong> 게임 트리에서 각 노드가 평균적으로 가지는 자식 노드의 수</p>
                
                <p><strong>ELO Rating:</strong> 체스에서 개발된 실력 평가 시스템으로, 상대적 실력을 수치화</p>
                
                <p><strong>Evaluation Function:</strong> 게임 상태의 유리함을 수치로 평가하는 함수</p>
                
                <p><strong>Horizon Effect:</strong> 제한된 탐색 깊이로 인해 중요한 결과를 놓치는 현상</p>
                
                <p><strong>Iterative Deepening:</strong> 탐색 깊이를 점진적으로 늘려가며 반복 탐색하는 기법</p>
                
                <p><strong>JavaScript Engine:</strong> JavaScript 코드를 실행하는 프로그램 (V8, SpiderMonkey, JavaScriptCore 등)</p>
                
                <p><strong>JIT Compilation:</strong> Just-In-Time 컴파일, 실행 시점에 기계어로 컴파일하는 기법</p>
                
                <p><strong>Killer Move:</strong> 이전에 베타 컷오프를 일으킨 수를 기억하여 우선 탐색하는 휴리스틱</p>
                
                <p><strong>Late Move Reduction:</strong> 후반부 수들의 탐색 깊이를 줄여 탐색 효율을 높이는 기법</p>
                
                <p><strong>Minimax:</strong> 2인 제로섬 게임에서 최악의 경우를 최선으로 만드는 의사결정 알고리즘</p>
                
                <p><strong>NegaScout:</strong> Principal Variation Search의 다른 이름으로, null-window search를 활용한 탐색 알고리즘</p>
                
                <p><strong>Nodes Per Second (NPS):</strong> 초당 탐색하는 노드 수로, AI 엔진의 속도 지표</p>
                
                <p><strong>Opening Book:</strong> 게임 초반 정석 수순을 저장한 데이터베이스</p>
                
                <p><strong>Principal Variation:</strong> 현재 평가에서 양측이 최선을 다한다고 가정했을 때의 수순</p>
                
                <p><strong>Quiescence Search:</strong> 조용한 위치에 도달할 때까지 캡처 등을 계속 탐색하는 기법</p>
                
                <p><strong>Transposition Table:</strong> 동일한 보드 상태의 평가 결과를 저장하는 해시 테이블</p>
                
                <p><strong>TypedArray:</strong> JavaScript에서 이진 데이터를 효율적으로 처리하는 배열 타입</p>
                
                
                
                <p><strong>Web Workers:</strong> JavaScript에서 백그라운드 스레드를 실행하는 웹 API</p>
                
                <p><strong>WebAssembly:</strong> 웹 브라우저에서 네이티브에 가까운 속도로 실행되는 바이너리 형식</p>
                
                <p><strong>Zobrist Hashing:</strong> 보드 상태를 빠르게 해싱하는 기법으로, XOR 연산을 활용</p>
            </div>
            
            <div class="page-number">93</div>
        </div>
        
        <!-- 참고문헌 -->
        <div class="page chapter">
            <div class="chapter-title">참고문헌</div>
            
            <div class="references">
                <div class="ref-item">
                    <span class="ref-number">[1]</span> Shannon, C. E. (1950). Programming a computer for playing chess. Philosophical Magazine, 41(314), 256-275.
                </div>
                
                <div class="ref-item">
                    <span class="ref-number">[2]</span> Samuel, A. L. (1959). Some studies in machine learning using the game of checkers. IBM Journal of Research and Development, 3(3), 210-229.
                </div>
                
                <div class="ref-item">
                    <span class="ref-number">[3]</span> Campbell, M., Hoane Jr, A. J., & Hsu, F. H. (2002). Deep Blue. Artificial Intelligence, 134(1-2), 57-83.
                </div>
                
                <div class="ref-item">
                    <span class="ref-number">[4]</span> Silver, D., Huang, A., Maddison, C. J., Guez, A., Sifre, L., Van Den Driessche, G., ... & Hassabis, D. (2016). Mastering the game of Go with deep neural networks and tree search. Nature, 529(7587), 484-489.
                </div>
                
                <div class="ref-item">
                    <span class="ref-number">[5]</span> Russell, S. J., & Norvig, P. (2020). Artificial Intelligence: A Modern Approach (4th ed.). Pearson.
                </div>
                
                <div class="ref-item">
                    <span class="ref-number">[6]</span> Knuth, D. E., & Moore, R. W. (1975). An analysis of alpha-beta pruning. Artificial Intelligence, 6(4), 293-326.
                </div>
                
                <div class="ref-item">
                    <span class="ref-number">[7]</span> Reinefeld, A. (1983). An improvement of the Scout tree search algorithm. ICCA Journal, 6(4), 4-14.
                </div>
                
                <div class="ref-item">
                    <span class="ref-number">[8]</span> Allis, L. V. (1994). Searching for solutions in games and artificial intelligence. PhD thesis, University of Limburg.
                </div>
                
                <div class="ref-item">
                    <span class="ref-number">[9]</span> Zobrist, A. L. (1970). A new hashing method with application for game playing. Technical Report 88, University of Wisconsin.
                </div>
                
                <div class="ref-item">
                    <span class="ref-number">[10]</span> Buro, M. (1999). The evolution of strong Othello programs. Entertainment Computing, 81-88.
                </div>
            </div>
            
            <div class="page-number">94</div>
        </div>
        
        <!-- Abstract (영문초록) -->
        <div class="page">
            <div class="abstract-title">Abstract</div>
            
            <div class="abstract-content">
                <p class="no-indent" style="text-align: center; font-weight: bold; margin-bottom: 20px;">
                    Implementation of High-Performance Game AI System in Browser Environment:<br>
                    An Empirical Study on Perfect Information Board Games
                </p>
                
                <p>
                    This thesis presents the design, implementation, and optimization methodology of a high-performance game artificial intelligence system using JavaScript and Web Workers in a web browser environment. Focusing on Othello, this research demonstrates that complex AI algorithms can be efficiently executed in browsers.
                </p>
                
                <p>
                    The core contributions include: (1) Implementation of Minimax with Alpha-Beta pruning and NegaScout algorithms optimized for JavaScript, achieving real-time performance; (2) Development of sophisticated evaluation functions with multi-phase evaluation for Othello; (3) Efficient caching strategies using Zobrist hashing and LRU replacement, achieving 65-78% cache hit rates.
                </p>
                
                <p>
                    Experimental results show that the Othello engine searches 120,000 nodes per second at 13-ply depth. The pure JavaScript implementation demonstrates the maturity of modern web technologies for high-performance AI systems.
                </p>
                
                <div class="keywords">
                    <strong>Keywords:</strong> Game AI, Browser Computing, Minimax, Alpha-Beta Pruning, Web Workers, JavaScript Optimization
                </div>
            </div>
            
            <div class="page-number">95</div>
        </div>
        
</div>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    
</body>
</html>